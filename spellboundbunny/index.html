<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Spellbound Bunny</title>
  <style>
  #instructionOverlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* Push items to the top */
  padding: 20px;
  padding-bottom: calc(40px + env(safe-area-inset-bottom));
  box-sizing: border-box;
}

#startGameBtn {
  margin-top: auto;
  margin-bottom: calc(20px + env(safe-area-inset-bottom));
  padding: 12px 24px;
  font-size: 18px;
  border-radius: 8px;
  background: #fff;
  color: #222;
  border: none;
  font-family: Garamond, serif;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }
    canvas {
      display: block;
      background: linear-gradient(to top, #333, #666);
      touch-action: none;
    }
	
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="settingsToggle" style="position: absolute; top: 10px; right: 10px; z-index: 10;">‚öôÔ∏è Settings</button>
<div id="settingsPanel" style="display: none; position: absolute; top: 50px; right: 10px; background: #333; color: white; padding: 10px; border: 1px solid #555; border-radius: 4px; z-index: 10;">
  <label for="speedSlider">Game Speed:</label><br>
  <input type="range" id="speedSlider" min="1" max="15" step="0.1" value="5">
  <span id="speedValue">5</span><br><br>
  <label><input type="checkbox" id="voiceToggle" checked> Enable Voice</label>

  <label><input type="checkbox" id="hardMode"> Hard Mode</label><br><br>

  <label for="missingLettersSlider">Missing Letters:</label><br>
  <input type="range" id="missingLettersSlider" min="0" max="3" step="1" value="0">
  <span id="missingLettersValue">0</span>
  <hr style="margin: 10px 0;">
  <div style="font-size: 14px; color: #aaa;">Version: <span id="versionLabel">...</span></div>
  <span id="visitorCount"></span>
</div>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6ZNJFGRJ7T"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-6ZNJFGRJ7T');
</script>

  <script>
  const GAME_VERSION = "v1.0.18"; // üîÅ Update this as needed
  const showTrees = true;
  const BASE_JUMP_DURATION = 20; // Tweak this for feel
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  let JUMP_HEIGHT = canvas.height * 0.1;
  let playerSize = canvas.height * 0.07;
  let SPAWN_EVERY_PX = 180; // will be recalculated
  const laneCount = 3;
  let lanes = [];
  let playerY = canvas.height * 0.8;
  let gamePaused = false;
  let autoPlayMode = true;
let powerups = [];
  let leftTreeX, rightTreeX;
let canBurrow = false; // üö´ Burrowing disabled by default

function updateTreePositions() {
    leftTreeX = Math.round(window.innerWidth * 0.05);
    rightTreeX = Math.round(window.innerWidth * 0.95);
}
function getObstacleTopY(obs) {
   if (obs.type === "snake") return obs.y - 20;
  if (obs.type === "fox" && obs.isStanding) return obs.y - 20;
  if (obs.type === "owl") return obs.y - 20;
  return obs.y;
}
function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;

    const displayWidth = window.innerWidth;
    const displayHeight = window.innerHeight;

    canvas.style.width = displayWidth + "px";
    canvas.style.height = displayHeight + "px";

    canvas.width = Math.floor(displayWidth * dpr);
    canvas.height = Math.floor(displayHeight * dpr);

    ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
    ctx.scale(dpr, dpr);

    // Update game logic dimensions based on window size (NOT canvas.height)
    playerY = displayHeight * 0.8;
    // üîΩ Cap the max jump height to 120px regardless of display height
    JUMP_HEIGHT = Math.min(displayHeight * 0.13, 120); 
    playerSize = displayHeight * 0.07;
    SPAWN_EVERY_PX = Math.max(100, displayHeight * 0.4);

    updateLanes();
    updateTreePositions(); // <-- call here
}

window.addEventListener("resize", resizeCanvas);
window.addEventListener("orientationchange", resizeCanvas);
resizeCanvas(); // Call once initially


let bgY = 0;
let scrollSinceLastSpawn = 0;
let wordStreak = 0;
let playerLane = 1;


function updateLanes() {
  lanes = Array.from({ length: laneCount }, (_, i) =>
    ((i + 1) * window.innerWidth) / (laneCount + 1)
  );
}
let burrowDustParticles = [];
let burrowTimer = 0;        // countdown in frames (10s * 60fps)
let showBurrowTimer = false;
    let obstacles = [];
    let letters = [];
    let collectedLetters = [];
    let targetWord = "";
    let nextWord = "";
    let score = 0;
let scorePulseFrame = 0;
const SCORE_PULSE_DURATION = 60;
let scorePops = [];
    let gameOver = false;

let missingIndices = [];

    let currentWordLength = 3;
    const BASE_WORD_LENGTH = 3;
    const MAX_WORD_LENGTH = 9;

    const SPEED_INCREMENT = 0.05;
    const MAX_SPEED_MULTIPLIER = 2.0;
    const BASE_SPEED = 5;
    let currentSpeed = BASE_SPEED;
    let spawnInterval = 1000;
    let spawnTimer;

    let touchStartX = null;
let touchStartY = null;
    let hopFrame = 0;
    let walkFrame = 0;
let isJumping = false;
let landingFrame = 0;
let isBurrowed = false;

let jumpFrame = 0;
let jumpLandOffset = 0;

    const bunnyTheme_0 = `
C5:4 R:2 D5:4 E5:4 R:2
G5:8 F5:4 E5:2 D5:2 R:4
C5:4 G4:4 A4:4 R:2 C5:4
E5:8 R:4 F5:2 G5:2 C6:4 R:4
`;
    const bunnyTheme_1 = `
C5:2 E5:2 G5:2 R:2 G5:2 A5:4
F5:2 D5:2 C5:4 R:2 C5:2 G5:4
E5:2 R:2 E5:2 G5:2 A5:4 R:4
C6:2 B5:2 A5:2 G5:2 R:4
`;
    const bunnyTheme_2 = `
A5:2 B5:2 C6:4 R:1 C6:2 D6:2 R:1
E6:4 R:2 G5:2 A5:2 B5:2 C6:4
R:2 G5:2 A5:2 F5:2 D5:2 R:4
C6:2 E6:2 D6:4 R:2 G5:2 C6:4
`;

	const bunnyTheme_3 = `
	C6:2 B5:2 A5:2 G5:2 F5:2 E5:2 D5:2 C5:2
C5:4 R:2 C4:2 G4:4 R:4
`;

let jumpDuration = 20; // default, will get recalculated
let bunnyPlayer;

    const commonWords = [
  "THE", "AND", "YOU", "FOR", "ARE", "WITH", "THIS", "HAVE", "FROM", "ONE",
  "WORD", "TIME", "YEAR", "MAKE", "GOOD", "PEOPLE", "LOOK", "WANT", "COME", "USE",
  "FIND", "GIVE", "WORK", "MANY", "THING", "FIRST", "WELL", "LIFE", "EVEN", "TELL",
  "CALL", "LONG", "GREAT", "HELP", "SAY", "KEEP", "TURN", "MOST", "RIGHT", "TRY",
  "NEW", "OLD", "DAY", "HIGH", "OFF", "NEXT", "NAME", "SHOW", "FEEL", "MOVE",
  "OVER", "BACK", "NEVER", "PLACE", "AFTER", "STILL", "HOME", "WORLD", "UNDER", "SMALL",
  "AGAIN", "EVERY", "START", "GROUP", "STATE", "POINT", "LARGE", "THINK", "WHERE", "THREE",
  "WHILE", "NUMBER", "ABOUT", "WATER", "THING", "THOSE", "FAMILY", "AROUND", "ALWAYS", "HOUSE",
  "ALMOST", "SCHOOL", "FRIEND", "STORY", "ALONE", "MONEY", "MOTHER", "FATHER", "MUSIC", "HAPPY",
  "CLOSE", "REALLY", "SOMETHING", "BEFORE", "LEARN", "LITTLE", "LEAVE", "YOUNG", "STAND", "EVER",
  "NIGHT", "LIGHT", "HEART", "VOICE", "ENJOY", "TOGETHER", "QUESTION", "ANSWER", "TRUTH", "MEET",
  "BUILD", "CLEAR", "CHANGE", "LEADER", "FOCUS", "STUDY", "HARD", "EASY", "SHORT", "STRONG",
  "COVER", "PIECE", "CAUSE", "REASON", "BEGIN", "ORDER", "BETTER", "INSIDE", "OUTSIDE", "NATURE",
  "EARLY", "FINAL", "CHOICE", "ENOUGH", "POWER", "NATION", "PUBLIC", "PERSON", "SYSTEM", "RIGHTS",
  "OFTEN", "LEVEL", "RESULT", "PROCESS", "REPORT", "SOCIAL", "HUMAN", "VALUES", "CENTER", "MIND",
  "VOICE", "BODY", "IMAGE", "MODEL", "SKILL", "TOOLS", "MARKET", "DRIVE", "EVENT", "TIMES",
  "SPACE", "FORM", "LINES", "FIELD", "TOPIC", "IDEAS", "VALUE", "GOALS", "MAYBE", "RULES",
  "BREAK", "LIMIT", "WORTH", "STEPS", "CHAIN", "CLOCK", "SPEED", "SCENE", "SCORE", "PLANS",
  "TYPES", "PLANT", "EARTH", "THINK", "NAMES", "THEME", "FRONT", "MOVES", "PLANE", "TRAIN",
  "CROSS", "TRACK", "POINT", "GRADE", "GRAPH", "RANGE", "ANGLE", "SCALE", "STARS", "FLASH",
  "PAINT", "PIANO", "SOUND", "VOICE", "COLOR", "SHAPE", "BRING", "DRINK", "LAUGH", "SMILE",
  "WATCH", "TASTE", "SMELL", "FEARS", "SHARE", "THROW", "WRITE", "READS", "SENDS", "WORDS",
  "CHECK", "MATCH", "LEADS", "PLAYS", "TRIES", "ENJOY", "LOVES", "HATES", "DREAM", "RESTS",
  "RISES", "FALLS", "CLOUD", "STORM", "SUNNY", "RAINY", "WAVES", "WINDY", "FIRES", "PLANS",
  "TOOLS", "IDEAS", "TRUTH", "CAUSE", "EFFECT", "NOTES", "TIMES", "NAMES", "TYPES", "VIEWS",
  "VISIT", "STOPS", "CALLS", "HELLO", "NIGHT", "MORNS", "MORAL", "FABLE", "LIONS", "TIGER",
  "HORSE", "RABIT", "BEARS", "MOUSE", "SHEEP", "ZEBRA", "BIRDS", "BEES", "PLANS", "MAPLE",
  "BREAD", "WHEAT", "RICE", "NOISE", "QUIET", "BLUES", "TUNES", "SINGS", "HUMMS", "MELOD",
  "NOTES", "SONGS", "PLAYS", "GAMES", "CHESS", "CARDS", "BLOCK", "STACK", "FALLS", "SHAPE",
  "CUBES", "ROLLS", "BALLS", "ROUND", "TUBES", "STICK", "GLUE", "TAPE", "FOLDS", "TURNS",
  "JUMPS", "HOPS", "RUNNS", "WALKS", "SKIPS", "PUSH", "PULL", "KICKS", "BENDS", "LIFTS",
  "CATCH", "THROW", "TURNS", "START", "PAUSE", "RESET", "LOOPS", "BREAK", "RETRY", "BEGIN",
  "WATCH", "START", "CHILD", "YOUTH", "ADULT", "ELDER", "WOMAN", "MANLY", "TEENS", "YOUNG",
  "OLDER", "KNOWS", "LEARN", "SHARE", "TEACH", "GUIDE", "LEADS", "BUILD", "MAKES", "FINDS",
  "PLANS", "CHOSE", "FOLKS", "CROWD", "GROUP", "CLASS", "GRADE", "LEVEL", "DEGREE", "POINT",
  "LINES", "SLOPE", "TILES", "FLOOR", "WALLS", "DOORS", "CLOSE", "OPENS", "LOCKS", "TURNS"
];

document.body.addEventListener("touchmove", (e) => {
  e.preventDefault();
}, { passive: false });



async function preloadWord(length) {
  try {
    const hardMode = document.getElementById("hardMode")?.checked;
    if (hardMode) {
      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);
      const data = await res.json();
      return data[0].toUpperCase();
    } else {
      const candidates = commonWords.filter(word => word.length === length);
      const choice = candidates[Math.floor(Math.random() * candidates.length)];
      return choice;
    }
  } catch {
    return "RUN";
      }
    }

    async function initWords() {
      targetWord = await preloadWord(currentWordLength);
      missingIndices = generateMissingIndices();
      nextWord = await preloadWord(currentWordLength + 1);
    }

    document.addEventListener("keydown", (e) => {
		
if ((e.key === "ArrowDown" || e.key === "s" || e.key === "S") && canBurrow) {
  isBurrowed = true;
}
if ((e.key === "ArrowUp" || e.key === "w" || e.key === "W") && isBurrowed) {
  isBurrowed = false;
}
		
		
  if (e.key === "ArrowUp" && !isJumping) {
    isJumping = true;
    const screenFactor = Math.min(canvas.height / 800, 1.5); // cap exaggeration
jumpDuration = Math.floor(BASE_JUMP_DURATION * screenFactor * (BASE_SPEED / currentSpeed));

	jumpFrame = jumpDuration;
  }
      const activeEl = document.activeElement;
      if (activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA")) return;
      if ((e.key === "ArrowLeft" || e.key === "a" || e.key === "A") && playerLane > 0) {
        playerLane--;
        hopFrame = 10;
      }
      if ((e.key === "ArrowRight" || e.key === "d" || e.key === "D") && playerLane < 2) {
        playerLane++;
        hopFrame = 10;
      }
    });

    canvas.addEventListener("touchstart", (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});

canvas.addEventListener("touchend", (e) => {
  if (touchStartX === null || touchStartY === null) return;

  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const diffX = touchEndX - touchStartX;
  const diffY = touchStartY - touchEndY; // upward swipe = positive

  const absX = Math.abs(diffX);
  const absY = Math.abs(diffY);

  // Prioritize horizontal swipes
  if (absX > absY && absX > 30) {
    if (diffX > 0 && playerLane < 2) {
      playerLane++;
      hopFrame = 10;
    } else if (diffX < 0 && playerLane > 0) {
      playerLane--;
      hopFrame = 10;
    }
  }   // Vertical swipe
  else if (absY > absX && absY > 30) {
    if (diffY > 50) {
      // Swipe up
      if (isBurrowed) {
        console.log("üü¢ Unburrowing");
        isBurrowed = false;
      } else if (!isJumping) {
        console.log("‚¨ÜÔ∏è Jump triggered");
        isJumping = true;
        const screenFactor = Math.min(canvas.height / 800, 1.5);
        jumpDuration = Math.floor(BASE_JUMP_DURATION * screenFactor * (BASE_SPEED / currentSpeed));
        jumpFrame = jumpDuration;
      }
    } else if (diffY < -50) {
      // Swipe down
  if (canBurrow) {
    console.log("‚¨áÔ∏è Burrow triggered");
    isBurrowed = true;
  } else {
    console.log("‚ùå Burrow not yet unlocked");
  }
    }
  }
  touchStartX = null;
  touchStartY = null;
});


function drawBurrowDust() {
  const x = lanes[playerLane];
  const y = playerY + 45; // Ground level

  // üîÅ Only emit particles every other frame (optional throttle)
  if (walkFrame % 2 === 0) {
    for (let i = 0; i < 2; i++) {
      burrowDustParticles.push({
        x: x + (Math.random() - 0.5) * 20,
        y: y,
        radius: 3 + Math.random() * 3,
        vx: (Math.random() - 0.5) * 0.8,
        vy: -0.5 - Math.random() * 1.5,
        alpha: 1
      });
    }
  }

  // ‚úÖ CAP: Limit total particles to 300
  if (burrowDustParticles.length > 300) {
    burrowDustParticles.splice(0, burrowDustParticles.length - 300);
  }

  // Draw and update particles
  for (let i = burrowDustParticles.length - 1; i >= 0; i--) {
    const p = burrowDustParticles[i];
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = "#a98f74";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();

    // Move
    p.x += p.vx;
    p.y += p.vy;
    p.alpha -= 0.02;
    p.radius *= 0.97;

    if (p.alpha <= 0 || p.radius < 0.5) {
      burrowDustParticles.splice(i, 1);
    }
  }
  ctx.globalAlpha = 1;

  // Base dust ring
  ctx.fillStyle = "#553c2b";
  ctx.beginPath();
  ctx.ellipse(x, y, 16, 6, 0, 0, Math.PI * 2);
  ctx.fill();
}



    function drawPlayer() {
		if (isBurrowed) {
 
  return;
}
		
  const jumpOffset = isJumping ? -Math.sin((jumpDuration - jumpFrame) / jumpDuration * Math.PI) * JUMP_HEIGHT : 0;
      ctx.fillStyle = "white";
      const x = lanes[playerLane];
      const forwardOffset = 0;
      let settleOffset = 0;
      if (landingFrame > 0) {
        const bounce = Math.sin((10 - landingFrame) / 10 * Math.PI);
        settleOffset = bounce * 8 * (1 - (10 - landingFrame) / 10); // taper bounce down
      }
      const y = playerY + jumpOffset + forwardOffset + settleOffset + jumpLandOffset;

      // Bunny body and head
      ctx.beginPath();
      ctx.ellipse(x, y + 22, 18, 22, 0, 0, Math.PI * 2); // body
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y - 4, 14, 0, Math.PI * 2); // head
      ctx.fill();

      // Ears with black highlights
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.moveTo(x - 8, y - 16);
      ctx.quadraticCurveTo(x - 12, y - 40, x - 6, y - 46);
      ctx.quadraticCurveTo(x - 2, y - 30, x - 8, y - 16);
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + 8, y - 16);
      ctx.quadraticCurveTo(x + 12, y - 40, x + 6, y - 46);
      ctx.quadraticCurveTo(x + 2, y - 30, x + 8, y - 16);
      ctx.fill();
      ctx.stroke();

      // Tail puff
      ctx.beginPath();
      ctx.arc(x, y + 36, 5, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.stroke();

      // Shadow
      const shadowWidth = isJumping ? 10 : 14;
      const shadowHeight = isJumping ? 3 : 5;
      const shadowOpacity = isJumping ? 0.1 : 0.2;
      ctx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
      ctx.beginPath();
      ctx.ellipse(x, y + 45, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";

      // Feet
      const footY = y + 40;

if (isJumping) {
  // Show both feet stable during jump
  ctx.fillRect(x - 10, footY, 5, 10);
  ctx.fillRect(x + 5, footY, 5, 10);
} else if (hopFrame > 0) {
  ctx.fillRect(x - 12, footY, 5, 10);
  ctx.fillRect(x + 7, footY, 5, 10);
} else {
  if (walkFrame % 40 < 20) {
    ctx.fillRect(x - 12, footY, 5, 10);
  } else {
    ctx.fillRect(x + 7, footY, 5, 10);
  }
}

    }

/*
    function drawObstacle(obs) {
      const { x, y } = obs;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y + 20, 20, Math.PI, 0, false);
      ctx.lineTo(x + 20, y + 20);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      for (let i = -3; i <= 3; i++) {
        const spikeX = x + i * 6;
        const spikeY = y + 20;
        ctx.beginPath();
        ctx.moveTo(spikeX, spikeY);
        ctx.lineTo(spikeX + 3, spikeY - 6);
        ctx.lineTo(spikeX + 6, spikeY);
        ctx.stroke();
      }
    }
*/
function drawFoxObstacle(obs) {
  const { x, y, isRaised: raiseHands } = obs;
  const scale = 0.6;

  ctx.save();
  const standOffset = obs.isStanding ? -20 : 0; // ‚¨ÜÔ∏è Shift fox upwards when standing
ctx.translate(x, y + standOffset);
  ctx.scale(scale, scale);

  // Body
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-25, 60);
  ctx.lineTo(25, 60);
  ctx.closePath();
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  // Chest
  ctx.beginPath();
  ctx.moveTo(0, 20);
  ctx.lineTo(-10, 50);
  ctx.lineTo(10, 50);
  ctx.closePath();
  ctx.fillStyle = "#fbeec1";
  ctx.fill();

  // Head
  ctx.beginPath();
  ctx.moveTo(0, -50);
  ctx.lineTo(-30, -10);
  ctx.lineTo(30, -10);
  ctx.closePath();
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  // Face mask
  ctx.beginPath();
  ctx.moveTo(0, -30);
  ctx.lineTo(-15, -10);
  ctx.lineTo(15, -10);
  ctx.closePath();
  ctx.fillStyle = "#fbeec1";
  ctx.fill();

  // Ears
  ctx.beginPath();
  ctx.moveTo(-30, -10);
  ctx.lineTo(-40, -40);
  ctx.lineTo(-20, -20);
  ctx.closePath();
  ctx.fillStyle = "#d35400";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(30, -10);
  ctx.lineTo(40, -40);
  ctx.lineTo(20, -20);
  ctx.closePath();
  ctx.fillStyle = "#d35400";
  ctx.fill();

  // Eyes
  ctx.beginPath();
  ctx.arc(-10, -20, 3, 0, Math.PI * 2);
  ctx.arc(10, -20, 3, 0, Math.PI * 2);
  ctx.fillStyle = "#000";
  ctx.fill();

  // Nose
  ctx.beginPath();
  ctx.arc(0, -10, 4, 0, Math.PI * 2);
  ctx.fill();

  // üêæ Animated Hands
if (obs.isStanding) {
  // Stand: taller body, legs visible

  // Extended legs (standing)
  ctx.beginPath();
  ctx.moveTo(-15, 60);
  ctx.lineTo(-15, 90);
  ctx.lineTo(-5, 90);
  ctx.lineTo(-5, 60);
  ctx.closePath();
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(15, 60);
  ctx.lineTo(15, 90);
  ctx.lineTo(5, 90);
  ctx.lineTo(5, 60);
  ctx.closePath();
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  // Shadow on ground
  ctx.beginPath();
  ctx.ellipse(0, 95, 20, 6, 0, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
  ctx.fill();

} else {
  // Sitting posture (default = body to ground)

  // Tail (already in sitting position)
  ctx.beginPath();
  ctx.moveTo(25, 60);
  ctx.quadraticCurveTo(50, 40, 30, 10);
  ctx.quadraticCurveTo(45, 40, 25, 60);
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(30, 20);
  ctx.quadraticCurveTo(40, 35, 20, 55);
  ctx.fillStyle = "#fbeec1";
  ctx.fill();

  // Shadow when sitting
  ctx.beginPath();
  ctx.ellipse(0, 66, 20, 6, 0, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
  ctx.fill();
}


  // Tail
  ctx.beginPath();
  ctx.moveTo(25, 60);
  ctx.quadraticCurveTo(50, 40, 30, 10);
  ctx.quadraticCurveTo(45, 40, 25, 60);
  ctx.fillStyle = "#e67e22";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(30, 20);
  ctx.quadraticCurveTo(40, 35, 20, 55);
  ctx.fillStyle = "#fbeec1";
  ctx.fill();

  ctx.restore();
}


function drawObstacle(obs) {
  if (obs.type === "fox") {
    drawFoxObstacle(obs);
  } else if (obs.type === "snake"){
    drawSnakeObstacle(obs); // your renamed former drawObstacle
  } else if (obs.type === "owl"){
	  drawOwlObstacle(obs);
  }
}
function drawOwlObstacle(obs) {
  const { x, y } = obs;
  const scale = 0.6;
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);

  // Set explicit stroke and line width
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;

  // Body
  ctx.beginPath();
  ctx.ellipse(0, 60, 35, 60, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#8B4513"; // brown
  ctx.fill();
  ctx.stroke();

  // Wings
  ctx.beginPath();
  ctx.ellipse(-25, 60, 15, 50, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#CD853F"; // tan
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.ellipse(25, 60, 15, 50, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#CD853F";
  ctx.fill();
  ctx.stroke();

  // Head
  ctx.beginPath();
  ctx.ellipse(0, 0, 50, 40, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#8B4513";
  ctx.fill();
  ctx.stroke();

  // Eyes
  ctx.beginPath();
  ctx.arc(-20, 0, 15, 0, Math.PI * 2);
  ctx.arc(20, 0, 15, 0, Math.PI * 2);
  ctx.fillStyle = "white";
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(-20, 0, 6, 0, Math.PI * 2);
  ctx.arc(20, 0, 6, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

  // Beak
  ctx.beginPath();
  ctx.moveTo(0, 10);
  ctx.lineTo(-6, 20);
  ctx.lineTo(6, 20);
  ctx.closePath();
  ctx.fillStyle = "gold";
  ctx.fill();
  ctx.stroke();

  // Ears
  ctx.beginPath();
  ctx.moveTo(-30, -20);
  ctx.lineTo(-40, -40);
  ctx.lineTo(-20, -30);
  ctx.closePath();
  ctx.fillStyle = "#8B4513";
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(30, -20);
  ctx.lineTo(40, -40);
  ctx.lineTo(20, -30);
  ctx.closePath();
  ctx.fillStyle = "#8B4513";
  ctx.fill();
  ctx.stroke();

  // Feet
  ctx.fillStyle = "orange";
  ctx.beginPath();
  ctx.moveTo(-10, 115);
  ctx.lineTo(-5, 125);
  ctx.lineTo(-15, 125);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(10, 115);
  ctx.lineTo(15, 125);
  ctx.lineTo(5, 125);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawSnakeObstacle(obs) {
  const { x, y } = obs;

	// Coils (omit the largest bottom one)
	const scale = 0.75; // 25% smaller
	const coilHeights = [0, 10, 20].map(h => h * scale);
	const coilWidths = [40, 60, 80].map(w => w * scale);

	const bodyColors = ["#a97453", "#c49b66", "#a97453"];
    
	
	for (let i = 0; i < coilWidths.length; i++) {
	  ctx.beginPath();
	  ctx.ellipse(x, y + coilHeights[i], coilWidths[i] / 2, 14 * scale, 0, 0, Math.PI * 2);

	  ctx.fillStyle = bodyColors[i];
	  ctx.strokeStyle = "black";
	  ctx.lineWidth = 1;
	  ctx.fill();
	  ctx.stroke();
	}

// Rattle segments (attached to third coil)
const baseY = y + 20 * scale;
for (let i = 0; i < 4; i++) {
  ctx.beginPath();
  ctx.ellipse(x + (45 + i * 6) * scale, baseY, 5 * scale, 8 * scale, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#e1c48a";
  ctx.strokeStyle = "black";
  ctx.fill();
  ctx.stroke();
}

  // ‚¨á Smaller Head (scaled down and moved slightly lower)
  const headY = y - 25 * scale;
  ctx.beginPath();
  ctx.ellipse(x, headY, 14 * scale, 20 * scale, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#5d4037";
  ctx.strokeStyle = "black";
  ctx.fill();
  ctx.stroke();

  // ‚¨á Eyes (smaller and repositioned)
  ctx.beginPath();
ctx.ellipse(x - 5 * scale, headY - 2 * scale, 4 * scale, 8 * scale, 0, 0, Math.PI * 2);
ctx.ellipse(x + 5 * scale, headY - 2 * scale, 4 * scale, 8 * scale, 0, 0, Math.PI * 2);

  ctx.fillStyle = "white";
  ctx.fill();
  ctx.strokeStyle = "black";
  ctx.stroke();

  // ‚¨á Pupils
  ctx.beginPath();
ctx.ellipse(x - 5 * scale, headY - 2 * scale, 1.5 * scale, 3 * scale, 0, 0, Math.PI * 2);
ctx.ellipse(x + 5 * scale, headY - 2 * scale, 1.5 * scale, 3 * scale, 0, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

// Tongue (longer, wider fork, more visible)
ctx.beginPath();
ctx.moveTo(x, headY + 8 * scale);
ctx.lineTo(x - 4 * scale, headY + 22 * scale);
ctx.lineTo(x, headY + 16 * scale);
ctx.lineTo(x + 4 * scale, headY + 22 * scale);
ctx.closePath();
ctx.fillStyle = "#ff3333";             // brighter red
ctx.fill();
ctx.strokeStyle = "black";             // outline for contrast
ctx.lineWidth = 1;
ctx.stroke();
}


    function drawLetter(letterObj) {
  const x = letterObj.x;
  const y = letterObj.y;

  // Carrot shape
  ctx.fillStyle = "orange";
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x - 19.7, y + 11, x - 12.2, y + 36, x, y + 48);
  ctx.bezierCurveTo(x + 12.2, y + 36, x + 19.7, y + 11, x, y);
  ctx.fill();

  ctx.strokeStyle = "#cc6600";
  ctx.lineWidth = 1;
  for (let i = 1; i < 4; i++) {
    ctx.beginPath();
    ctx.moveTo(x - 4, y + i * 8);
    ctx.lineTo(x + 4, y + i * 8);
    ctx.stroke();
  }

  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - 5, y - 12);
  ctx.lineTo(x - 2, y);
  ctx.lineTo(x + 2, y - 14);
  ctx.lineTo(x + 4, y);
  ctx.closePath();
  ctx.fill();

  // ‚úÖ Fix: Set font and measure *after* all carrot drawing
  const fontSize = 22;
  ctx.font = `${fontSize}px Garamond`;
  ctx.fillStyle = "black";
  ctx.textAlign = "left";        // ‚úÖ fix for misalignment
ctx.textBaseline = "alphabetic"; // ‚úÖ fix for vertical misalignment

  const metrics = ctx.measureText(letterObj.letter);
  const letterWidth = metrics.width;
  const ascent = metrics.actualBoundingBoxAscent || fontSize * 0.75;

  const centerX = x - (letterWidth / 2);
  const centerY = y + 48 - (48 - ascent) / 2;

  ctx.fillText(letterObj.letter, centerX, centerY);
}


    function drawTargetWord() {
      const fontSize = 36.4;
      ctx.font = `${fontSize}px Garamond`;
      const spacing = 6;
      const letterWidths = targetWord.split('').map(l => ctx.measureText(l).width);
      const totalWidth = letterWidths.reduce((a, b) => a + b, 0) + (targetWord.length - 1) * spacing;
      const startX = (window.innerWidth - totalWidth) / 2;
      const y = 50;
      const missingCount = parseInt(document.getElementById("missingLettersSlider").value);
      
      // missingIndices is now generated once per word

      let x = startX;
      for (let i = 0; i < targetWord.length; i++) {
        ctx.fillStyle = missingIndices.includes(i) ? "gray" : (collectedLetters[i] === targetWord[i] ? "lime" : "white");
        const showLetter = missingIndices.includes(i)
          ? (collectedLetters[i] === targetWord[i] ? targetWord[i] : "_")
          : targetWord[i];
        ctx.fillText(showLetter, x, y);
        x += letterWidths[i] + spacing;
      }
    }

    function spawnObstacle() {
		if (autoPlayMode) return; // üö´ Prevent anything during autoplay
      const laneIndices = [0, 1, 2];
      const redLanes = [];

let powerupLane = null;
if (Math.random() < 0.05) { // 5% chance
  powerupLane = Math.floor(Math.random() * 3);
  powerups.push({ x: lanes[powerupLane], y: -50, type: "burrow", collected: false });

}

      laneIndices.forEach(lane => {
  if (lane === powerupLane) return; // üö´ Skip powerup lane

  if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER) {
    if (Math.random() < 0.4) redLanes.push(lane);
  } else {
    if (Math.random() < 0.7) redLanes.push(lane);
  }
});

      if (redLanes.length >= 3) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);
      if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER && redLanes.length >= 2) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);

      redLanes.forEach(lane => {
let availableAnimals = ["snake"];
if (wordStreak >= 2) availableAnimals.push("fox");
if (wordStreak >= 4) availableAnimals.push("owl");

const animal = availableAnimals[Math.floor(Math.random() * availableAnimals.length)];
	  
  obstacles.push({
  x: lanes[lane],
  y: -50,
  type: animal,
  poseTimer: 0,         // üîÅ animation timer
  isStanding: false     // üßç pose flag
});
});

      if (Math.random() < 0.36 && targetWord && collectedLetters.length < targetWord.length) {
        let letterToShow;
        if (Math.random() < 0.5) {
          letterToShow = targetWord[collectedLetters.length];
        } else {
          letterToShow = targetWord[Math.floor(Math.random() * targetWord.length)];
        }

        const availableLanes = laneIndices.filter(l => !redLanes.includes(l) && l !== powerupLane);

        if (availableLanes.length > 0) {
          const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
          letters.push({ letter: letterToShow, x: lanes[lane], y: -50 });
        }
      }
    }
let alternateCarrotTheme = true;
    async function update() {
		if (burrowTimer > 0) {
  burrowTimer--;
  if (burrowTimer === 0) {
    isBurrowed = false;
    canBurrow = false;
    showBurrowTimer = false;
  }
}
		
		
		if (!isBurrowed) {
  burrowDustParticles = [];
}
		
		
      if (gameOver) return;
      if (gamePaused) return;

      const effectiveSpeed = isJumping ? currentSpeed * 1.75 : currentSpeed;
const poseCycle = 4000;     // Total cycle time (3s)
const standDuration = 3000; // Fox stands for 1s, sits for 2s

for (let obs of obstacles) {
  if (obs.type === "fox") {
    obs.poseTimer += effectiveSpeed * 16; // Adjust for scroll speed
    const t = obs.poseTimer % poseCycle;
    obs.isStanding = (t < standDuration); // First 1s = standing, rest = sitting
  }
}
      bgY += effectiveSpeed * 0.5;
      if (bgY > canvas.height) bgY = 0;

const scrollDelta = effectiveSpeed;
scrollSinceLastSpawn += scrollDelta;

if (scrollSinceLastSpawn >= SPAWN_EVERY_PX && !gameOver && !gamePaused && !autoPlayMode) {
  spawnObstacle();
  scrollSinceLastSpawn = 0;
}


      ctx.fillStyle = '#88b37f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
	if (showTrees) {
		for (let y = Math.floor(bgY % 100) - 100; y < canvas.height; y += 100) {
			const snappedY = Math.round(y); // snap to pixel

			ctx.fillStyle = '#5a3e1b';
			[leftTreeX, rightTreeX].forEach(x => {
			  ctx.fillStyle = '#5a3e1b';
			  ctx.fillRect(x, snappedY + 40, 10, 40); // trunk

			  ctx.beginPath();
			  ctx.fillStyle = '#2f6b2f';
			  ctx.arc(x + 5, snappedY + 30, 20, 0, Math.PI * 2); // canopy
			  ctx.fill();
			});
		}
	}

      if (autoPlayMode && Math.random() < 0.02 && !isJumping) {
        isJumping = true;
        jumpFrame = 20;
      }
      if (autoPlayMode && hopFrame === 0 && Math.random() < 0.02) {
        const direction = Math.random() < 0.5 ? -1 : 1;
        const newLane = playerLane + direction;
        if (newLane >= 0 && newLane <= 2) {
          playerLane = newLane;
          hopFrame = 10;
        }
      }
      if (isBurrowed) {
		  drawBurrowDust(); // ‚úÖ Dust comes *under* obstacles now
		}
 if (showBurrowTimer && burrowTimer > 0) {
  const total = 600; // 10 seconds * 60 FPS
  const remaining = burrowTimer;
  const progress = remaining / total;

  const barWidth = 160;
  const barHeight = 16;
  const x = canvas.clientWidth / 2 - barWidth / 2;
const y = canvas.clientHeight - 60;


  // Background
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.fillRect(x, y, barWidth, barHeight);
  ctx.strokeStyle = "white";
  ctx.strokeRect(x, y, barWidth, barHeight);

  // Fill
  ctx.fillStyle = "#b77bff"; // light purple
  ctx.fillRect(x, y, barWidth * progress, barHeight);

  // Optional label
  ctx.font = "14px Garamond";
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.fillText("Burrow", canvas.width / 2, y - 6);
}
      for (let obs of obstacles) {
        obs.y += effectiveSpeed;
        drawObstacle(obs);

        if (!isJumping && !isBurrowed &&
              getObstacleTopY(obs) + playerSize > playerY &&
    getObstacleTopY(obs) < playerY + playerSize &&
    obs.x === lanes[playerLane]) {
          gameOver = true;
		  bunnyPlayer.interruptAndPlay(bunnyTheme_3, 120);
          document.getElementById("gameOverOverlay").style.display = "flex";
          document.getElementById("finalScore").textContent = score;

          return;

        }
      }

      for (let i = letters.length - 1; i >= 0; i--) {
        const letter = letters[i];
        letter.y += effectiveSpeed;
        ctx.font = "22px Garamond"; // force reset here
		drawLetter(letter);

        if (!isJumping && !isBurrowed &&
          letter.y + playerSize > playerY &&
          letter.y < playerY + playerSize &&
          letter.x === lanes[playerLane]) {
          const expected = targetWord[collectedLetters.length];
          if (letter.letter === expected) {
		  const isCompletingWord = collectedLetters.length + 1 === targetWord.length;
		  if (!isCompletingWord){
  score += 1;

  // Always push +1 above bunny head, but mark whether it's part of final word
  scorePops.push({
    x: lanes[playerLane] - 10,
    y: playerY - 20,
    text: "+1",
    alpha: 1,
    frame: 0,
    color: "black",
    isFinalLetter: isCompletingWord  // <- flag it
  });
  } else {
    scorePops.push({
    x: lanes[playerLane] - 10,
    y: playerY - 20,
    text: "X2",
    alpha: 1,
    frame: 0,
    color: "black",
    isFinalLetter: isCompletingWord  // <- flag it
  });
  }


			if (!bunnyPlayer.isPlaying()) {
				console.log("Alpahbet play");
				bunnyPlayer.interruptAndPlay(bunnyTheme_0, 120);
				} else {
			  if (alternateCarrotTheme) {
				bunnyPlayer.queue(bunnyTheme_1, 120);
			  } else {
				bunnyPlayer.queue(bunnyTheme_0, 120);
			  }
			  alternateCarrotTheme = !alternateCarrotTheme;
			}
		   
		   
            
          
          collectedLetters.push(letter.letter);
            if (document.getElementById("voiceToggle")?.checked) {
          const sayLetter = new SpeechSynthesisUtterance(letter.letter);
          sayLetter.lang = "en-GB";
          speechSynthesis.speak(sayLetter);
              }
          } else {
             collectedLetters = [];
  score = Math.max(0, score - 1);
  scorePops.push({ x: lanes[playerLane] - 10, y: playerY - 20, text: "-1", alpha: 1, frame: 0 });
          }
          letters.splice(i, 1);
        }
      }

      drawTargetWord();
	  
	  for (let i = powerups.length - 1; i >= 0; i--) {
  const p = powerups[i];
  p.y += effectiveSpeed;

  // Draw purple carrot
  const x = p.x;
  const y = p.y;
  ctx.fillStyle = "purple";
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x - 19.7, y + 11, x - 12.2, y + 36, x, y + 48);
  ctx.bezierCurveTo(x + 12.2, y + 36, x + 19.7, y + 11, x, y);
  ctx.fill();

  ctx.strokeStyle = "#9900cc";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Green stem
  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - 5, y - 12);
  ctx.lineTo(x + 5, y - 12);
  ctx.closePath();
  ctx.fill();

  // Collision check
if (!isJumping &&
    !p.collected &&
    y + playerSize > playerY &&
    y < playerY + playerSize &&
    x === lanes[playerLane]) {

  p.collected = true; // ‚úÖ mark so we don't collect it again
  canBurrow = true;

if (!isBurrowed && burrowTimer <= 0) {
  isBurrowed = true;
  burrowTimer = 600;
}


  showBurrowTimer = true;
  bunnyPlayer.interruptAndPlay(bunnyTheme_1, 120);
  powerups.splice(i, 1);
}


}

	  
	  
	  
      drawPlayer();
	  
	  
      ctx.fillStyle = "white";
      const baseFontSize = 16;
      const pulseSize = scorePulseFrame > 0 ? baseFontSize + scorePulseFrame * 1.5 : baseFontSize;
      ctx.font = `${pulseSize}px Garamond`;
      const scoreText = "Score: " + score;
      const textWidth = ctx.measureText(scoreText).width;
      // Background
		ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
		ctx.fillRect(8, 8, textWidth + 24, 28);

		// Text
		ctx.shadowColor = "#000";
		ctx.shadowBlur = 4;
		ctx.fillStyle = "white";
		ctx.fillText("ü•ï " + score, 16, 28);
		ctx.shadowBlur = 0;
      if (scorePulseFrame > 0) scorePulseFrame--;
	  
      scorePops.forEach((pop, i) => {
ctx.globalAlpha = 1; // no transparency
ctx.fillStyle = (pop.text === "-1") ? "red" : "black"; // strong red for -1, black otherwise

  // Make +1 and -1 25% larger
  const baseSize = 16;
  const fontSize = (pop.text === "+1" || pop.text === "-1") ? baseSize * 1.50 : baseSize;
  ctx.font = `${fontSize}px Garamond`;

  ctx.fillText(pop.text, pop.x, pop.y);
  ctx.globalAlpha = 1;

  pop.y -= 1;
  pop.alpha -= 0.03;
  if (pop.alpha <= 0) scorePops.splice(i, 1);
});

      if (collectedLetters.join("") === targetWord) {
		  wordStreak++; // ‚úÖ increment streak
        bunnyPlayer.interruptAndPlay(bunnyTheme_2, 120);
        if (document.getElementById("voiceToggle")?.checked) {
        const utterance = new SpeechSynthesisUtterance(targetWord);
        utterance.lang = "en-GB";
        speechSynthesis.speak(utterance);
          }
		score = score * 2;
		scorePulseFrame = SCORE_PULSE_DURATION;
        collectedLetters = [];
        currentSpeed = Math.min(currentSpeed + BASE_SPEED * SPEED_INCREMENT, BASE_SPEED * MAX_SPEED_MULTIPLIER);

        if (currentWordLength < MAX_WORD_LENGTH) {
          currentWordLength++;
        }

        targetWord = nextWord;
        missingIndices = generateMissingIndices();
        nextWord = await preloadWord(Math.min(currentWordLength + 1, MAX_WORD_LENGTH));
      }

      obstacles = obstacles.filter(obs => obs.y < canvas.height);
      letters = letters.filter(letter => letter.y < canvas.height);
	  powerups = powerups.filter(p => p.y < canvas.height);

    }


    function gameLoop() {
      update();
      walkFrame++;
      if (hopFrame > 0) hopFrame--;
      if (landingFrame > 0) {
        landingFrame--;
        jumpLandOffset *= 0.85; // gradually return to normal
        if (landingFrame === 0) jumpLandOffset = 0;
      }
      if (jumpFrame > 0) {
        jumpFrame--;
        if (jumpFrame === 0) {
        isJumping = false;
        landingFrame = 10;
        jumpLandOffset = -30; // bunny lands visually forward
      }
      }
      requestAnimationFrame(gameLoop);
    }

    document.getElementById("speedSlider").addEventListener("input", function(e) {
	  const val = parseFloat(e.target.value);
	  currentSpeed = val;
	  document.getElementById("speedValue").textContent = val;
	  localStorage.setItem("lastSpeed", val); // ‚Üê Add this line
	});

    document.getElementById("missingLettersSlider").addEventListener("input", function(e) {
      const value = parseInt(e.target.value);
      localStorage.setItem("missingCount", value);
      document.getElementById("missingLettersValue").textContent = value;
    });

    const savedSpeed = parseFloat(localStorage.getItem("lastSpeed"));
    if (!isNaN(savedSpeed)) {
      currentSpeed = savedSpeed;
      document.getElementById("speedSlider").value = savedSpeed;
      document.getElementById("speedValue").textContent = savedSpeed;
    }

    const savedMissing = parseInt(localStorage.getItem("missingCount"));
    if (!isNaN(savedMissing)) {
      document.getElementById("missingLettersSlider").value = savedMissing;
      document.getElementById("missingLettersValue").textContent = savedMissing;
    }

    const savedHardMode = localStorage.getItem("hardMode");
    if (savedHardMode !== null) {
      document.getElementById("hardMode").checked = savedHardMode === "true";
    }
    document.getElementById("hardMode").addEventListener("change", function(e) {
      localStorage.setItem("hardMode", e.target.checked);
    });

    const savedVoice = localStorage.getItem("voiceToggle");
    if (savedVoice !== null) {
      document.getElementById("voiceToggle").checked = savedVoice === "true";
    }
    document.getElementById("voiceToggle").addEventListener("change", function(e) {
      localStorage.setItem("voiceToggle", e.target.checked);
    });

    document.getElementById("settingsToggle").addEventListener("click", () => {
  const panel = document.getElementById("settingsPanel");
  const isVisible = panel.style.display === "block";
  panel.style.display = isVisible ? "none" : "block";
  gamePaused = !gamePaused;
});



    initWords().then(() => gameLoop());
  function generateMissingIndices() {
  const count = parseInt(document.getElementById("missingLettersSlider").value);
  const indices = [];
  while (indices.length < count && indices.length < targetWord.length) {
    const rand = Math.floor(Math.random() * targetWord.length);
    if (!indices.includes(rand)) indices.push(rand);
  }
  return indices;
}
document.addEventListener("visibilitychange", () => {
  if (document.hidden) {
    gamePaused = true;
  } else {
    const settingsPanel = document.getElementById("settingsPanel");
    const settingsOpen = settingsPanel && settingsPanel.style.display === "block";
    if (!autoPlayMode && !settingsOpen) {
      gamePaused = false;
    }
  }
});

function createQueuedChiptunePlayer(audioCtx,defaultBpm = 120) {
  let beatTime = 60 / defaultBpm;
  let melody = [];
  let originalMelody = [];
  let index = 0;
  let _isPlaying = false;
  let nextNoteTime = 0;
  let loop = false;
  let scheduler;
  const queue = [];

  function parse(input) {
    return input.trim().split(/\s+/).map(token => {
      if (token.startsWith("R:")) return { type: 'rest', duration: parseInt(token.split(":")[1]) };
      const [note, dur] = token.split(":");
      return { type: 'note', note, duration: parseInt(dur) };
    });
  }

  function totalQueuedNotes() {
    return queue.reduce((sum, item) => sum + parse(item.string).length, 0);
  }

  function freq(note) {
    const map = { C: 0, 'C#': 1, D: 2, 'D#': 3, E: 4, F: 5, 'F#': 6, G: 7, 'G#': 8, A: 9, 'A#': 10, B: 11 };
    const match = note.match(/^([A-G]#?)(\d)$/);
    if (!match) return 0;
    const [, n, o] = match;
    const midi = (parseInt(o) + 1) * 12 + map[n];
    return 440 * Math.pow(2, (midi - 69) / 12);
  }

  function playNote(noteObj, time) {
    if (noteObj.type === 'rest') return;
    const f = freq(noteObj.note);
    if (!isFinite(f)) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(f, time);
    gain.gain.setValueAtTime(0.25, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + 0.3);
  }

function schedule() {
  while (index < melody.length && nextNoteTime < audioCtx.currentTime + 0.1) {
    const note = melody[index];
    playNote(note, nextNoteTime);
    nextNoteTime += beatTime * (note.duration / 4);
    index++;
  }

  if (_isPlaying) {
    if (index < melody.length) {
      scheduler = requestAnimationFrame(schedule);
    } else if (loop) {
      melody = melody.concat(originalMelody);
      scheduler = requestAnimationFrame(schedule);
    } else if (queue.length > 0) {
      const next = queue.shift();
      startMelody(next.string, next.bpm, next.loop);
    } else {
      _isPlaying = false; // ‚úÖ Melody and queue both finished
    }
  }
}

  function startMelody(melodyString, bpm, shouldLoop) {
    originalMelody = parse(melodyString);
    melody = originalMelody.slice();
    index = 0;
    loop = shouldLoop;
    beatTime = 60 / bpm;
    nextNoteTime = audioCtx.currentTime;
    scheduler = requestAnimationFrame(schedule);
  }

  return {
    audioCtx, // ‚úÖ expose audio context so we can call resume() from outside
    /**
     * Queues a melody to be played after the current one.
     * Does nothing if it would exceed 20 notes total in the queue.
     */
    queue: (melodyString, bpm = defaultBpm, shouldLoop = false) => {
      const parsed = parse(melodyString);
	  console.log("Current melody queue length:", queue.length);
      queue.push({ string: melodyString, bpm, loop: shouldLoop });

      if (!_isPlaying ) {
        _isPlaying = true;
        const next = queue.shift();
		console.log("Start melody queue length:", queue.length);
        startMelody(next.string, next.bpm, next.loop);
      }
    },
    stop: () => {
      _isPlaying = false;
      cancelAnimationFrame(scheduler);
      queue.length = 0;
    },
	 getQueueLength: () => melody.length,
    isPlaying: () => _isPlaying,
	interruptAndPlay: (melodyString, bpm = defaultBpm, shouldLoop = false) => {
  queue.length = 0;            // Clear any queued melodies
  cancelAnimationFrame(scheduler); // Stop current scheduler loop
  _isPlaying = true;            // Flag as actively playing
  startMelody(melodyString, bpm, shouldLoop); // Start new melody immediately
}
  };
}




    
</script>

<div id="gameOverOverlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);color:white;font-family:Garamond,serif;z-index:25;align-items:center;justify-content:center;flex-direction:column;text-align:center;">
  <h2>Game Over</h2>
  <p style="font-size: 24px;">
  Your final score: <span id="finalScore">0</span> ü•ï
  </p>
  <button onclick="location.reload()" style="padding:10px 20px; font-size:18px; cursor:pointer;">Play Again</button>
</div>
<div id="instructionOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); color: white; font-family: Garamond, serif; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; text-align: center; padding: 20px;">
  <img src="bunny_splash.png" alt="Bunny Logo"
     style="width: 80%; max-width: 500px; height: auto; margin-bottom: 20px;" />
  <h2>How to Play</h2>
  <p>Swipe left or right to move.<br>Swipe up to jump over traps and collect the right letters.</p>
  <p>Your goal is to spell the target word correctly by collecting the right carrots!</p>
  <button id="startGameBtn" style="margin-top: 20px; padding: 10px 20px; font-size: 18px; cursor: pointer;">Start</button>
</div>

<script>
document.getElementById("startGameBtn").addEventListener("click", () => {
  autoPlayMode = false;
  document.getElementById("instructionOverlay").style.display = "none";
  gamePaused = false;

  // ‚úÖ Create AudioContext here ‚Äî inside user gesture
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  // ‚úÖ Resume it immediately
  audioCtx.resume().then(() => {
  console.log("‚úÖ Audio resumed");

    // üéß üîì iOS unlock hack: play a silent-ish tone immediately
    const dummy = audioCtx.createOscillator();
    dummy.frequency.setValueAtTime(440, audioCtx.currentTime);
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, audioCtx.currentTime); // silence it
    dummy.connect(gain).connect(audioCtx.destination);
    dummy.start(audioCtx.currentTime);
    dummy.stop(audioCtx.currentTime + 0.01); // 10 ms tone

  // Then initialize your chiptune player
  bunnyPlayer = createQueuedChiptunePlayer(audioCtx);
  bunnyPlayer.queue(bunnyTheme_0, 120);
});

});

  
  window.addEventListener("load", () => {
    gamePaused = true;
  });
  
  document.getElementById("versionLabel").textContent = GAME_VERSION;
</script>

</html>
