<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Subway Surfer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }
    canvas {
      display: block;
      background: linear-gradient(to top, #333, #666);
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <button id="settingsToggle" style="position: absolute; top: 10px; right: 10px; z-index: 10;">⚙️ Settings</button>
<div id="settingsPanel" style="display: none; position: absolute; top: 50px; right: 10px; background: #333; color: white; padding: 10px; border: 1px solid #555; border-radius: 4px; z-index: 10;">
  <label for="speedSlider">Game Speed:</label><br>
  <input type="range" id="speedSlider" min="1" max="15" step="0.1" value="5">
  <span id="speedValue">5</span><br><br>

  <label><input type="checkbox" id="hardMode"> Hard Mode</label><br><br>

  <label for="missingLettersSlider">Missing Letters:</label><br>
  <input type="range" id="missingLettersSlider" min="0" max="3" step="1" value="0">
  <span id="missingLettersValue">0</span>
</div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let bgY = 0;

    const lanes = [100, 200, 300];
    let playerLane = 1;
    const playerY = 500;
    const playerSize = 40;

    let obstacles = [];
    let letters = [];
    let collectedLetters = [];
    let targetWord = "";
    let nextWord = "";
    let score = 0;
    let gameOver = false;
let gamePaused = false;
let missingIndices = [];

    let currentWordLength = 3;
    const BASE_WORD_LENGTH = 3;
    const MAX_WORD_LENGTH = 9;

    const SPEED_INCREMENT = 0.05;
    const MAX_SPEED_MULTIPLIER = 2.0;
    const BASE_SPEED = 5;
    let currentSpeed = BASE_SPEED;
    let spawnInterval = 1000;
    let spawnTimer;

    let touchStartX = null;
    let hopFrame = 0;
    let walkFrame = 0;

    const commonWords = [
  "THE", "AND", "YOU", "FOR", "ARE", "WITH", "THIS", "HAVE", "FROM", "ONE",
  "WORD", "TIME", "YEAR", "MAKE", "GOOD", "PEOPLE", "LOOK", "WANT", "COME", "USE",
  "FIND", "GIVE", "WORK", "MANY", "THING", "FIRST", "WELL", "LIFE", "EVEN", "TELL",
  "CALL", "LONG", "GREAT", "HELP", "SAY", "KEEP", "TURN", "MOST", "RIGHT", "TRY",
  "NEW", "OLD", "DAY", "HIGH", "OFF", "NEXT", "NAME", "SHOW", "FEEL", "MOVE",
  "OVER", "BACK", "NEVER", "PLACE", "AFTER", "STILL", "HOME", "WORLD", "UNDER", "SMALL",
  "AGAIN", "EVERY", "START", "GROUP", "STATE", "POINT", "LARGE", "THINK", "WHERE", "THREE",
  "WHILE", "NUMBER", "ABOUT", "WATER", "THING", "THOSE", "FAMILY", "AROUND", "ALWAYS", "HOUSE",
  "ALMOST", "SCHOOL", "FRIEND", "STORY", "ALONE", "MONEY", "MOTHER", "FATHER", "MUSIC", "HAPPY",
  "CLOSE", "REALLY", "SOMETHING", "BEFORE", "LEARN", "LITTLE", "LEAVE", "YOUNG", "STAND", "EVER",
  "NIGHT", "LIGHT", "HEART", "VOICE", "ENJOY", "TOGETHER", "QUESTION", "ANSWER", "TRUTH", "MEET",
  "BUILD", "CLEAR", "CHANGE", "LEADER", "FOCUS", "STUDY", "HARD", "EASY", "SHORT", "STRONG",
  "COVER", "PIECE", "CAUSE", "REASON", "BEGIN", "ORDER", "BETTER", "INSIDE", "OUTSIDE", "NATURE",
  "EARLY", "FINAL", "CHOICE", "ENOUGH", "POWER", "NATION", "PUBLIC", "PERSON", "SYSTEM", "RIGHTS",
  "OFTEN", "LEVEL", "RESULT", "PROCESS", "REPORT", "SOCIAL", "HUMAN", "VALUES", "CENTER", "MIND",
  "VOICE", "BODY", "IMAGE", "MODEL", "SKILL", "TOOLS", "MARKET", "DRIVE", "EVENT", "TIMES",
  "SPACE", "FORM", "LINES", "FIELD", "TOPIC", "IDEAS", "VALUE", "GOALS", "MAYBE", "RULES",
  "BREAK", "LIMIT", "WORTH", "STEPS", "CHAIN", "CLOCK", "SPEED", "SCENE", "SCORE", "PLANS",
  "TYPES", "PLANT", "EARTH", "THINK", "NAMES", "THEME", "FRONT", "MOVES", "PLANE", "TRAIN",
  "CROSS", "TRACK", "POINT", "GRADE", "GRAPH", "RANGE", "ANGLE", "SCALE", "STARS", "FLASH",
  "PAINT", "PIANO", "SOUND", "VOICE", "COLOR", "SHAPE", "BRING", "DRINK", "LAUGH", "SMILE",
  "WATCH", "TASTE", "SMELL", "FEARS", "SHARE", "THROW", "WRITE", "READS", "SENDS", "WORDS",
  "CHECK", "MATCH", "LEADS", "PLAYS", "TRIES", "ENJOY", "LOVES", "HATES", "DREAM", "RESTS",
  "RISES", "FALLS", "CLOUD", "STORM", "SUNNY", "RAINY", "WAVES", "WINDY", "FIRES", "PLANS",
  "TOOLS", "IDEAS", "TRUTH", "CAUSE", "EFFECT", "NOTES", "TIMES", "NAMES", "TYPES", "VIEWS",
  "VISIT", "STOPS", "CALLS", "HELLO", "NIGHT", "MORNS", "MORAL", "FABLE", "LIONS", "TIGER",
  "HORSE", "RABIT", "BEARS", "MOUSE", "SHEEP", "ZEBRA", "BIRDS", "BEES", "PLANS", "MAPLE",
  "BREAD", "WHEAT", "RICE", "NOISE", "QUIET", "BLUES", "TUNES", "SINGS", "HUMMS", "MELOD",
  "NOTES", "SONGS", "PLAYS", "GAMES", "CHESS", "CARDS", "BLOCK", "STACK", "FALLS", "SHAPE",
  "CUBES", "ROLLS", "BALLS", "ROUND", "TUBES", "STICK", "GLUE", "TAPE", "FOLDS", "TURNS",
  "JUMPS", "HOPS", "RUNNS", "WALKS", "SKIPS", "PUSH", "PULL", "KICKS", "BENDS", "LIFTS",
  "CATCH", "THROW", "TURNS", "START", "PAUSE", "RESET", "LOOPS", "BREAK", "RETRY", "BEGIN",
  "WATCH", "START", "CHILD", "YOUTH", "ADULT", "ELDER", "WOMAN", "MANLY", "TEENS", "YOUNG",
  "OLDER", "KNOWS", "LEARN", "SHARE", "TEACH", "GUIDE", "LEADS", "BUILD", "MAKES", "FINDS",
  "PLANS", "CHOSE", "FOLKS", "CROWD", "GROUP", "CLASS", "GRADE", "LEVEL", "DEGREE", "POINT",
  "LINES", "SLOPE", "TILES", "FLOOR", "WALLS", "DOORS", "CLOSE", "OPENS", "LOCKS", "TURNS"
];

async function preloadWord(length) {
  try {
    const hardMode = document.getElementById("hardMode")?.checked;
    if (hardMode) {
      const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);
      const data = await res.json();
      return data[0].toUpperCase();
    } else {
      const candidates = commonWords.filter(word => word.length === length);
      const choice = candidates[Math.floor(Math.random() * candidates.length)];
      return choice;
    }
  } catch {
    return "RUN";
      }
    }

    async function initWords() {
      targetWord = await preloadWord(currentWordLength);
      missingIndices = generateMissingIndices();
      nextWord = await preloadWord(currentWordLength + 1);
    }

    document.addEventListener("keydown", (e) => {
      const activeEl = document.activeElement;
      if (activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA")) return;
      if ((e.key === "ArrowLeft" || e.key === "a" || e.key === "A") && playerLane > 0) {
        playerLane--;
        hopFrame = 10;
      }
      if ((e.key === "ArrowRight" || e.key === "d" || e.key === "D") && playerLane < 2) {
        playerLane++;
        hopFrame = 10;
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      touchStartX = e.touches[0].clientX;
    });

    canvas.addEventListener("touchend", (e) => {
      if (touchStartX === null) return;
      const touchEndX = e.changedTouches[0].clientX;
      const diffX = touchEndX - touchStartX;

      if (Math.abs(diffX) > 30) {
        if (diffX > 0 && playerLane < 2) {
          playerLane++;
          hopFrame = 10;
        } else if (diffX < 0 && playerLane > 0) {
          playerLane--;
          hopFrame = 10;
        }
      }
      touchStartX = null;
    });

    function drawPlayer() {
      ctx.fillStyle = "white";
      const x = lanes[playerLane];
      const y = playerY;

      // Bunny body and head
      ctx.beginPath();
      ctx.ellipse(x, y + 22, 18, 22, 0, 0, Math.PI * 2); // body
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y - 4, 14, 0, Math.PI * 2); // head
      ctx.fill();

      // Ears with black highlights
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.moveTo(x - 8, y - 16);
      ctx.quadraticCurveTo(x - 12, y - 40, x - 6, y - 46);
      ctx.quadraticCurveTo(x - 2, y - 30, x - 8, y - 16);
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + 8, y - 16);
      ctx.quadraticCurveTo(x + 12, y - 40, x + 6, y - 46);
      ctx.quadraticCurveTo(x + 2, y - 30, x + 8, y - 16);
      ctx.fill();
      ctx.stroke();

      // Tail puff
      ctx.beginPath();
      ctx.arc(x, y + 36, 5, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.stroke();

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.beginPath();
      ctx.ellipse(x, y + 45, 14, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";

      // Feet
      const footY = y + 40;
      if (hopFrame > 0) {
        ctx.fillRect(x - 12, footY, 5, 10);
        ctx.fillRect(x + 7, footY, 5, 10);
      } else {
        if (walkFrame % 40 < 20) {
          ctx.fillRect(x - 12, footY, 5, 10);
        } else {
          ctx.fillRect(x + 7, footY, 5, 10);
        }
      }
    }

    function drawObstacle(obs) {
      const { x, y } = obs;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y + 20, 20, Math.PI, 0, false);
      ctx.lineTo(x + 20, y + 20);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      for (let i = -3; i <= 3; i++) {
        const spikeX = x + i * 6;
        const spikeY = y + 20;
        ctx.beginPath();
        ctx.moveTo(spikeX, spikeY);
        ctx.lineTo(spikeX + 3, spikeY - 6);
        ctx.lineTo(spikeX + 6, spikeY);
        ctx.stroke();
      }
    }

    function drawLetter(letterObj) {
      const x = letterObj.x;
      const y = letterObj.y;

      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - 19.7, y + 11, x - 12.2, y + 36, x, y + 48);
      ctx.bezierCurveTo(x + 12.2, y + 36, x + 19.7, y + 11, x, y);
      ctx.fill();

      ctx.strokeStyle = "#cc6600";
      ctx.lineWidth = 1;
      for (let i = 1; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(x - 4, y + i * 8);
        ctx.lineTo(x + 4, y + i * 8);
        ctx.stroke();
      }

      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 5, y - 12);
      ctx.lineTo(x - 2, y);
      ctx.lineTo(x + 2, y - 14);
      ctx.lineTo(x + 4, y);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "black";
      ctx.font = "20px Garamond";
      ctx.fillText(letterObj.letter, x - 6, y + 36);
    }

    function drawTargetWord() {
      const fontSize = 36.4;
      ctx.font = `${fontSize}px Garamond`;
      const totalWidth = targetWord.length * 22;
      const startX = (canvas.width - totalWidth) / 2;
      const y = 50;
      const missingCount = parseInt(document.getElementById("missingLettersSlider").value);
      
      // missingIndices is now generated once per word

      for (let i = 0; i < targetWord.length; i++) {
        ctx.fillStyle = missingIndices.includes(i) ? "gray" : (collectedLetters[i] === targetWord[i] ? "lime" : "white");
        const showLetter = missingIndices.includes(i)
          ? (collectedLetters[i] === targetWord[i] ? targetWord[i] : "_")
          : targetWord[i];
        ctx.fillText(showLetter, startX + i * 22, y);
      }
    }

    function spawnObstacle() {
      const laneIndices = [0, 1, 2];
      const redLanes = [];

      laneIndices.forEach(lane => {
        if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER) {
          if (Math.random() < 0.4) redLanes.push(lane);
        } else {
          if (Math.random() < 0.7) redLanes.push(lane);
        }
      });

      if (redLanes.length >= 3) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);
      if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER && redLanes.length >= 2) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);

      redLanes.forEach(lane => {
        obstacles.push({ x: lanes[lane], y: -50 });
      });

      if (Math.random() < 0.36 && targetWord && collectedLetters.length < targetWord.length) {
        let letterToShow;
        if (Math.random() < 0.5) {
          letterToShow = targetWord[collectedLetters.length];
        } else {
          letterToShow = targetWord[Math.floor(Math.random() * targetWord.length)];
        }

        const availableLanes = laneIndices.filter(l => !redLanes.includes(l));
        if (availableLanes.length > 0) {
          const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
          letters.push({ letter: letterToShow, x: lanes[lane], y: -50 });
        }
      }
    }

    async function update() {
      if (gameOver || gamePaused) return;

      bgY += currentSpeed * 0.5;
      if (bgY > canvas.height) bgY = 0;

      ctx.fillStyle = '#88b37f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = bgY % 100 - 100; y < canvas.height; y += 100) {
        const sidePositions = [20, 360];
        sidePositions.forEach(x => {
          ctx.fillStyle = '#5a3e1b';
          ctx.fillRect(x, y + 40, 10, 40);

          ctx.beginPath();
          ctx.fillStyle = '#2f6b2f';
          ctx.arc(x + 5, y + 30, 20, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      drawPlayer();

      for (let obs of obstacles) {
        obs.y += currentSpeed;
        drawObstacle(obs);

        if (
          obs.y + playerSize > playerY &&
          obs.y < playerY + playerSize &&
          obs.x === lanes[playerLane]
        ) {
          gameOver = true;
          alert("Game Over! Score: " + score);
          localStorage.setItem("lastSpeed", currentSpeed);
          const speedSlider = document.getElementById("speedSlider");
          const lastSpeed = parseFloat(speedSlider.value);
          location.reload();
          speedSlider.value = lastSpeed;
          document.getElementById("speedValue").textContent = lastSpeed;
        }
      }

      for (let i = letters.length - 1; i >= 0; i--) {
        const letter = letters[i];
        letter.y += currentSpeed;
        drawLetter(letter);

        if (
          letter.y + playerSize > playerY &&
          letter.y < playerY + playerSize &&
          letter.x === lanes[playerLane]
        ) {
          const expected = targetWord[collectedLetters.length];
          if (letter.letter === expected) {
            collectedLetters.push(letter.letter);
          } else {
            collectedLetters = [];
            score = Math.max(0, score - 1);
          }
          letters.splice(i, 1);
        }
      }

      drawTargetWord();
      ctx.fillStyle = "white";
      ctx.font = "16px Garamond";
      const scoreText = "Score: " + score;
      const textWidth = ctx.measureText(scoreText).width;
      ctx.fillText(scoreText, 10, 20);

      if (collectedLetters.join("") === targetWord) {
        score += 1;
        collectedLetters = [];
        currentSpeed = Math.min(currentSpeed + BASE_SPEED * SPEED_INCREMENT, BASE_SPEED * MAX_SPEED_MULTIPLIER);

        if (currentWordLength < MAX_WORD_LENGTH) {
          currentWordLength++;
        }

        targetWord = nextWord;
        missingIndices = generateMissingIndices();
        nextWord = await preloadWord(Math.min(currentWordLength + 1, MAX_WORD_LENGTH));
      }

      obstacles = obstacles.filter(obs => obs.y < canvas.height);
      letters = letters.filter(letter => letter.y < canvas.height);
    }

    spawnTimer = setInterval(() => {
      if (!gameOver) spawnObstacle();
    }, spawnInterval);

    function gameLoop() {
      update();
      walkFrame++;
      if (hopFrame > 0) hopFrame--;
      requestAnimationFrame(gameLoop);
    }

    document.getElementById("speedSlider").addEventListener("input", function(e) {
      currentSpeed = parseFloat(e.target.value);
      document.getElementById("speedValue").textContent = e.target.value;
    });

    document.getElementById("missingLettersSlider").addEventListener("input", function(e) {
      const value = parseInt(e.target.value);
      localStorage.setItem("missingCount", value);
      document.getElementById("missingLettersValue").textContent = value;
    });

    const savedSpeed = parseFloat(localStorage.getItem("lastSpeed"));
    if (!isNaN(savedSpeed)) {
      currentSpeed = savedSpeed;
      document.getElementById("speedSlider").value = savedSpeed;
      document.getElementById("speedValue").textContent = savedSpeed;
    }

    const savedMissing = parseInt(localStorage.getItem("missingCount"));
    if (!isNaN(savedMissing)) {
      document.getElementById("missingLettersSlider").value = savedMissing;
      document.getElementById("missingLettersValue").textContent = savedMissing;
    }

    const savedHardMode = localStorage.getItem("hardMode");
    if (savedHardMode !== null) {
      document.getElementById("hardMode").checked = savedHardMode === "true";
    }

    document.getElementById("hardMode").addEventListener("change", function(e) {
      localStorage.setItem("hardMode", e.target.checked);
    });

    document.getElementById("settingsToggle").addEventListener("click", () => {
  const panel = document.getElementById("settingsPanel");
  const isVisible = panel.style.display === "block";
  panel.style.display = isVisible ? "none" : "block";
  gamePaused = !gamePaused;
});

    initWords().then(() => gameLoop());
  function generateMissingIndices() {
  const count = parseInt(document.getElementById("missingLettersSlider").value);
  const indices = [];
  while (indices.length < count && indices.length < targetWord.length) {
    const rand = Math.floor(Math.random() * targetWord.length);
    if (!indices.includes(rand)) indices.push(rand);
  }
  return indices;
}
</script>
</body>
</html>
