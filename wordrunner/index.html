<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Subway Surfer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }
    canvas {
      display: block;
      background: linear-gradient(to top, #333, #666);
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let bgY = 0;

    const lanes = [100, 200, 300];
    let playerLane = 1;
    const playerY = 500;
    const playerSize = 40;

    let obstacles = [];
    let letters = [];
    let collectedLetters = [];
    let targetWord = "";
    let nextWord = "";
    let score = 0;
    let gameOver = false;

    let currentWordLength = 3;
    const BASE_WORD_LENGTH = 3;
    const MAX_WORD_LENGTH = 9;

    const SPEED_INCREMENT = 0.05;
    const MAX_SPEED_MULTIPLIER = 2.0;
    const BASE_SPEED = 5;
    let currentSpeed = BASE_SPEED;
    let spawnInterval = 1000;
    let spawnTimer;

    let touchStartX = null;
    let hopFrame = 0;
    let walkFrame = 0;

    async function preloadWord(length) {
      try {
        const res = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);
        const data = await res.json();
        return data[0].toUpperCase();
      } catch {
        return "RUN";
      }
    }

    async function initWords() {
      targetWord = await preloadWord(currentWordLength);
      nextWord = await preloadWord(currentWordLength + 1);
    }

    document.addEventListener("keydown", (e) => {
      if ((e.key === "ArrowLeft" || e.key === "a" || e.key === "A") && playerLane > 0) {
        playerLane--;
        hopFrame = 10;
      }
      if ((e.key === "ArrowRight" || e.key === "d" || e.key === "D") && playerLane < 2) {
        playerLane++;
        hopFrame = 10;
      }
    });

    canvas.addEventListener("touchstart", (e) => {
      touchStartX = e.touches[0].clientX;
    });

    canvas.addEventListener("touchend", (e) => {
      if (touchStartX === null) return;
      const touchEndX = e.changedTouches[0].clientX;
      const diffX = touchEndX - touchStartX;

      if (Math.abs(diffX) > 30) {
        if (diffX > 0 && playerLane < 2) {
          playerLane++;
          hopFrame = 10;
        } else if (diffX < 0 && playerLane > 0) {
          playerLane--;
          hopFrame = 10;
        }
      }
      touchStartX = null;
    });

    function drawPlayer() {
      ctx.fillStyle = "white";
      const x = lanes[playerLane];
      const y = playerY;

      // Bunny body and head
      ctx.beginPath();
      ctx.ellipse(x, y + 22, 18, 22, 0, 0, Math.PI * 2); // body
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y - 4, 14, 0, Math.PI * 2); // head
      ctx.fill();

      // Ears with black highlights
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.moveTo(x - 8, y - 16);
      ctx.quadraticCurveTo(x - 12, y - 40, x - 6, y - 46);
      ctx.quadraticCurveTo(x - 2, y - 30, x - 8, y - 16);
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x + 8, y - 16);
      ctx.quadraticCurveTo(x + 12, y - 40, x + 6, y - 46);
      ctx.quadraticCurveTo(x + 2, y - 30, x + 8, y - 16);
      ctx.fill();
      ctx.stroke();

      // Tail puff
      ctx.beginPath();
      ctx.arc(x, y + 36, 5, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.stroke();

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.beginPath();
      ctx.ellipse(x, y + 45, 14, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";

      // Feet
      const footY = y + 40;
      if (hopFrame > 0) {
        ctx.fillRect(x - 12, footY, 5, 10);
        ctx.fillRect(x + 7, footY, 5, 10);
      } else {
        if (walkFrame % 40 < 20) {
          ctx.fillRect(x - 12, footY, 5, 10);
        } else {
          ctx.fillRect(x + 7, footY, 5, 10);
        }
      }
    }

    function drawObstacle(obs) {
      const { x, y } = obs;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(x, y + 20, 20, Math.PI, 0, false);
      ctx.lineTo(x + 20, y + 20);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      for (let i = -3; i <= 3; i++) {
        const spikeX = x + i * 6;
        const spikeY = y + 20;
        ctx.beginPath();
        ctx.moveTo(spikeX, spikeY);
        ctx.lineTo(spikeX + 3, spikeY - 6);
        ctx.lineTo(spikeX + 6, spikeY);
        ctx.stroke();
      }
    }

    function drawLetter(letterObj) {
      const x = letterObj.x;
      const y = letterObj.y;

      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.bezierCurveTo(x - 19.7, y + 11, x - 12.2, y + 36, x, y + 48);
      ctx.bezierCurveTo(x + 12.2, y + 36, x + 19.7, y + 11, x, y);
      ctx.fill();

      ctx.strokeStyle = "#cc6600";
      ctx.lineWidth = 1;
      for (let i = 1; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(x - 4, y + i * 8);
        ctx.lineTo(x + 4, y + i * 8);
        ctx.stroke();
      }

      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - 5, y - 12);
      ctx.lineTo(x - 2, y);
      ctx.lineTo(x + 2, y - 14);
      ctx.lineTo(x + 4, y);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "black";
      ctx.font = "20px Garamond";
      ctx.fillText(letterObj.letter, x - 6, y + 36);
    }

    function drawTargetWord() {
      const fontSize = 36.4;
      ctx.font = `${fontSize}px Garamond`;
      const totalWidth = targetWord.length * 22;
      const startX = (canvas.width - totalWidth) / 2;
      const y = 50;
      for (let i = 0; i < targetWord.length; i++) {
        ctx.fillStyle = collectedLetters[i] === targetWord[i] ? "lime" : "white";
        ctx.fillText(targetWord[i], startX + i * 22, y);
      }
    }

    function spawnObstacle() {
      const laneIndices = [0, 1, 2];
      const redLanes = [];

      laneIndices.forEach(lane => {
        if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER) {
          if (Math.random() < 0.4) redLanes.push(lane);
        } else {
          if (Math.random() < 0.7) redLanes.push(lane);
        }
      });

      if (redLanes.length >= 3) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);
      if (currentSpeed < BASE_SPEED * MAX_SPEED_MULTIPLIER && redLanes.length >= 2) redLanes.splice(Math.floor(Math.random() * redLanes.length), 1);

      redLanes.forEach(lane => {
        obstacles.push({ x: lanes[lane], y: -50 });
      });

      if (Math.random() < 0.36 && targetWord && collectedLetters.length < targetWord.length) {
        let letterToShow;
        if (Math.random() < 0.5) {
          letterToShow = targetWord[collectedLetters.length];
        } else {
          letterToShow = targetWord[Math.floor(Math.random() * targetWord.length)];
        }

        const availableLanes = laneIndices.filter(l => !redLanes.includes(l));
        if (availableLanes.length > 0) {
          const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
          letters.push({ letter: letterToShow, x: lanes[lane], y: -50 });
        }
      }
    }

    async function update() {
      if (gameOver) return;

      bgY += currentSpeed * 0.5;
      if (bgY > canvas.height) bgY = 0;

      ctx.fillStyle = '#88b37f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = bgY % 100 - 100; y < canvas.height; y += 100) {
        const sidePositions = [20, 360];
        sidePositions.forEach(x => {
          ctx.fillStyle = '#5a3e1b';
          ctx.fillRect(x, y + 40, 10, 40);

          ctx.beginPath();
          ctx.fillStyle = '#2f6b2f';
          ctx.arc(x + 5, y + 30, 20, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      drawPlayer();

      for (let obs of obstacles) {
        obs.y += currentSpeed;
        drawObstacle(obs);

        if (
          obs.y + playerSize > playerY &&
          obs.y < playerY + playerSize &&
          obs.x === lanes[playerLane]
        ) {
          gameOver = true;
          alert("Game Over! Score: " + score);
          document.location.reload();
        }
      }

      for (let i = letters.length - 1; i >= 0; i--) {
        const letter = letters[i];
        letter.y += currentSpeed;
        drawLetter(letter);

        if (
          letter.y + playerSize > playerY &&
          letter.y < playerY + playerSize &&
          letter.x === lanes[playerLane]
        ) {
          const expected = targetWord[collectedLetters.length];
          if (letter.letter === expected) {
            collectedLetters.push(letter.letter);
          } else {
            collectedLetters = [];
            score = Math.max(0, score - 1);
          }
          letters.splice(i, 1);
        }
      }

      drawTargetWord();
      ctx.fillStyle = "white";
      ctx.font = "16px Garamond";
      const scoreText = "Score: " + score;
      const textWidth = ctx.measureText(scoreText).width;
      ctx.fillText(scoreText, canvas.width - textWidth - 10, 20);

      if (collectedLetters.join("") === targetWord) {
        score += 1;
        collectedLetters = [];
        currentSpeed = Math.min(currentSpeed + BASE_SPEED * SPEED_INCREMENT, BASE_SPEED * MAX_SPEED_MULTIPLIER);

        if (currentWordLength < MAX_WORD_LENGTH) {
          currentWordLength++;
        }

        targetWord = nextWord;
        nextWord = await preloadWord(Math.min(currentWordLength + 1, MAX_WORD_LENGTH));
      }

      obstacles = obstacles.filter(obs => obs.y < canvas.height);
      letters = letters.filter(letter => letter.y < canvas.height);
    }

    spawnTimer = setInterval(() => {
      if (!gameOver) spawnObstacle();
    }, spawnInterval);

    function gameLoop() {
      update();
      walkFrame++;
      if (hopFrame > 0) hopFrame--;
      requestAnimationFrame(gameLoop);
    }

    initWords().then(() => gameLoop());
  </script>
</body>
</html>
