<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classic Canvas Chess</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body { display: grid; place-items: center; background: #f5f7fb; }
    .wrap { display: grid; gap: 12px; justify-items: center; }
    canvas { background: #fff; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.08); touch-action: none; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: center; }
    button { padding: 10px 14px; border-radius: 10px; border: 0; box-shadow: 0 6px 16px rgba(0,0,0,.08); background: #2d7ef7; color: #fff; font-weight: 700; cursor: pointer; }
    button.secondary { background: #e7ecf5; color: #1f2937; }
    .note { max-width: 720px; font-size: 14px; color: #374151; line-height: 1.4; text-align: center; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="board" width="720" height="720" aria-label="Chess board" role="img"></canvas>
    <div class="row">
      <button id="newGame">New Game</button>
      <button id="toggleHints" class="secondary">Hints: On</button>
      <button id="flip" class="secondary">Flip Board</button>
    </div>
    <div class="note">
      Classic set rendering with Unicode chess glyphs. No external images used.
    </div>
  </div>

  <script>
    // =============================
    // Classic Canvas Chess (Unicode set)
    // =============================
    // - No images: pieces drawn using Unicode glyphs ♙♖♘♗♕♔ / ♟♜♞♝♛♚
    // - Mouse & touch
    // - Legal moves (no castling or en passant), auto queen promotion

    const SIZE = 720;
    const DIM = 8;
    const SQ = SIZE / DIM;
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    const COLORS = {
      light: '#F2F6FF',
      dark: '#87A7DF',
      select: '#ffd16688',
      hint: '#06b6d4aa',
      capture: '#ef444488',
      grid: '#cbd5e1'
    };

    let boardFlipped = false;
    let showHints = true;

    // Unicode glyphs for standard pieces
    const GLYPH = {
      w: { p: '♙', r: '♖', n: '♘', b: '♗', q: '♕', k: '♔' },
      b: { p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚' }
    };

    // Game state
    let pieces = []; // {type, color, x, y, id, hasMoved}
    let turn = 'w';
    let selected = null; // piece id
    let legalMoves = []; // {x,y, capture?:boolean}

    const inBounds = (x,y) => x>=0 && x<8 && y>=0 && y<8;
    function at(x,y){ return pieces.find(p=>p.x===x && p.y===y); }

    function setupPieces(){
      pieces = [];
      const add = (type,color,x,y)=> pieces.push({type,color,x,y,id:crypto.randomUUID(),hasMoved:false});
      for(let i=0;i<8;i++){ add('p','w',i,1); add('p','b',i,6); }
      add('r','w',0,0); add('r','w',7,0); add('r','b',0,7); add('r','b',7,7);
      add('n','w',1,0); add('n','w',6,0); add('n','b',1,7); add('n','b',6,7);
      add('b','w',2,0); add('b','w',5,0); add('b','b',2,7); add('b','b',5,7);
      add('q','w',3,0); add('q','b',3,7);
      add('k','w',4,0); add('k','b',4,7);
      turn = 'w'; selected = null; legalMoves = [];
    }

    function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

    function genMoves(piece){
      const {type,color,x,y} = piece;
      const dir = (color==='w') ? 1 : -1;
      const moves = [];
      const pushIfEmpty = (nx,ny)=>{ if(inBounds(nx,ny) && !at(nx,ny)) moves.push({x:nx,y:ny}); };
      const pushIfCapture = (nx,ny)=>{ if(inBounds(nx,ny)){ const t=at(nx,ny); if(t && t.color!==color) moves.push({x:nx,y:ny,capture:true}); } };
      const ray = (dx,dy)=>{ let nx=x+dx, ny=y+dy; while(inBounds(nx,ny)){ const t=at(nx,ny); if(!t) moves.push({x:nx,y:ny}); else { if(t.color!==color) moves.push({x:nx,y:ny,capture:true}); break; } nx+=dx; ny+=dy; } };
      switch(type){
        case 'p': pushIfEmpty(x, y+dir); if(!piece.hasMoved && !at(x,y+dir) && !at(x,y+2*dir)) pushIfEmpty(x, y+2*dir); pushIfCapture(x-1, y+dir); pushIfCapture(x+1, y+dir); break;
        case 'r': ray(1,0); ray(-1,0); ray(0,1); ray(0,-1); break;
        case 'b': ray(1,1); ray(-1,1); ray(1,-1); ray(-1,-1); break;
        case 'q': ray(1,0); ray(-1,0); ray(0,1); ray(0,-1); ray(1,1); ray(-1,1); ray(1,-1); ray(-1,-1); break;
        case 'n': [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]].forEach(([dx,dy])=>{ const nx=x+dx, ny=y+dy; if(!inBounds(nx,ny)) return; const t=at(nx,ny); if(!t || t.color!==color) moves.push({x:nx,y:ny,capture:!!t}); }); break;
        case 'k': for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){ if(dx===0 && dy===0) continue; const nx=x+dx, ny=y+dy; if(!inBounds(nx,ny)) continue; const t=at(nx,ny); if(!t || t.color!==color) moves.push({x:nx,y:ny,capture:!!t}); } break;
      }
      return moves.filter(m => !wouldLeaveKingInCheck(piece, m));
    }

    function genMovesNoCheckFilter(piece){
      const {type,color,x,y} = piece;
      const dir = (color==='w') ? 1 : -1;
      const moves = [];
      const inB = (nx,ny)=> nx>=0 && nx<8 && ny>=0 && ny<8;
      const at2 = (nx,ny)=> pieces.find(p=>p.x===nx && p.y===ny);
      const pushEmpty = (nx,ny)=>{ if(inB(nx,ny) && !at2(nx,ny)) moves.push({x:nx,y:ny}); };
      const pushCap = (nx,ny)=>{ if(inB(nx,ny)){ const t=at2(nx,ny); if(t && t.color!==color) moves.push({x:nx,y:ny,capture:true}); } };
      const ray = (dx,dy)=>{ let nx=x+dx, ny=y+dy; while(inB(nx,ny)){ const t=at2(nx,ny); if(!t) moves.push({x:nx,y:ny}); else { if(t.color!==color) moves.push({x:nx,y:ny,capture:true}); break;} nx+=dx; ny+=dy; } };
      switch(type){
        case 'p': pushEmpty(x, y+dir); if(!piece.hasMoved && !at2(x,y+dir) && !at2(x,y+2*dir)) pushEmpty(x, y+2*dir); pushCap(x-1, y+dir); pushCap(x+1, y+dir); break;
        case 'r': ray(1,0); ray(-1,0); ray(0,1); ray(0,-1); break;
        case 'b': ray(1,1); ray(-1,1); ray(1,-1); ray(-1,-1); break;
        case 'q': ray(1,0); ray(-1,0); ray(0,1); ray(0,-1); ray(1,1); ray(-1,1); ray(1,-1); ray(-1,-1); break;
        case 'n': [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]].forEach(([dx,dy])=>{ const nx=x+dx, ny=y+dy; if(!inB(nx,ny)) return; const t=at2(nx,ny); if(!t || t.color!==color) moves.push({x:nx,y:ny,capture:!!t}); }); break;
        case 'k': for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){ if(dx===0 && dy===0) continue; const nx=x+dx, ny=y+dy; if(!inB(nx,ny)) continue; const t=at2(nx,ny); if(!t || t.color!==color) moves.push({x:nx,y:ny,capture:!!t}); } break;
      }
      return moves;
    }

    function wouldLeaveKingInCheck(piece, move){
      const target = at(move.x, move.y);
      const backup = JSON.parse(JSON.stringify(pieces));
      if(target){ pieces = pieces.filter(p=>p.id!==target.id); }
      const orig = {x:piece.x, y:piece.y};
      piece.x = move.x; piece.y = move.y;
      const inCheck = isKingInCheck(piece.color);
      pieces = backup; // restore
      return inCheck;
    }

    function isKingInCheck(color){
      const king = pieces.find(p=>p.type==='k' && p.color===color);
      if(!king) return false;
      const enemy = pieces.filter(p=>p.color!==color);
      return enemy.some(e=> genMovesNoCheckFilter(e).some(m=> m.x===king.x && m.y===king.y));
    }

    function movePiece(piece, move){
      const target = at(move.x, move.y);
      if(target){ pieces = pieces.filter(p=>p.id!==target.id); }
      piece.x = move.x; piece.y = move.y; piece.hasMoved = true;
      if(piece.type==='p' && (piece.y===7 || piece.y===0)) piece.type='q';
      turn = (turn==='w') ? 'b' : 'w';
      selected = null; legalMoves = [];
      const hasAnyMove = pieces.filter(p=>p.color===turn).some(p=> genMoves(p).length>0);
      if(!hasAnyMove){
        const check = isKingInCheck(turn);
        setTimeout(()=>{ alert(check ? `Checkmate! ${(turn==='w'?'Black':'White')} wins.` : 'Stalemate!'); }, 10);
      }
      draw();
    }

    function drawBoard(){
      ctx.clearRect(0,0,SIZE,SIZE);
      for(let y=0;y<8;y++){
        for(let x=0;x<8;x++){
          const rx = boardFlipped? 7-x : x;
          const ry = boardFlipped? 7-y : y;
          const isDark = (x+y)%2===1;
          ctx.fillStyle = isDark? COLORS.dark : COLORS.light;
          ctx.fillRect(rx*SQ, (7-ry)*SQ, SQ, SQ);
        }
      }
      ctx.strokeStyle = COLORS.grid;
      ctx.lineWidth = 1;
      for(let i=0;i<=8;i++){
        ctx.beginPath(); ctx.moveTo(i*SQ,0); ctx.lineTo(i*SQ,SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,i*SQ); ctx.lineTo(SIZE,i*SQ); ctx.stroke();
      }
    }

    function drawPieces(){
      for(const p of pieces){
        const rx = boardFlipped? 7-p.x : p.x;
        const ry = boardFlipped? 7-p.y : p.y;
        const cx = rx*SQ + SQ/2;
        const cy = (7-ry)*SQ + SQ/2 + SQ*0.06; // small baseline tweak
        const glyph = GLYPH[p.color][p.type];
        ctx.save();
        ctx.font = `${Math.floor(SQ*0.72)}px \"Segoe UI Symbol\", \"Noto Color Emoji\", \"Apple Color Emoji\", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // subtle shadow for legibility
        ctx.shadowColor = 'rgba(0,0,0,0.15)';
        ctx.shadowBlur = 4;
        ctx.fillStyle = p.color==='w' ? '#ffffff' : '#111827';
        ctx.fillText(glyph, cx, cy);
        ctx.restore();
      }
    }

    function highlightSelection(){
      if(!selected) return;
      const p = pieces.find(pp=>pp.id===selected); if(!p) return;
      const rx = boardFlipped? 7-p.x : p.x;
      const ry = boardFlipped? 7-p.y : p.y;
      ctx.save();
      ctx.fillStyle = COLORS.select;
      ctx.fillRect(rx*SQ, (7-ry)*SQ, SQ, SQ);
      if(showHints){
        for(const m of legalMoves){
          const mx = boardFlipped? 7-m.x : m.x;
          const my = boardFlipped? 7-m.y : m.y;
          ctx.fillStyle = m.capture? COLORS.capture : COLORS.hint;
          const r = SQ*0.16;
          ctx.beginPath(); ctx.arc(mx*SQ+SQ/2, (7-my)*SQ+SQ/2, r, 0, Math.PI*2); ctx.fill();
        }
      }
      ctx.restore();
    }

    function draw(){
      drawBoard();
      highlightSelection();
      drawPieces();
    }

    function squareFromClient(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left; const y = clientY - rect.top;
      const sx = Math.floor(x / SQ); const sy = Math.floor(y / SQ);
      const rx = boardFlipped? 7 - sx : sx;
      const ry = boardFlipped? 7 - (7 - sy) : (7 - sy);
      return {x: rx, y: ry};
    }

    function pickAt(x,y){ return pieces.find(p=>p.x===x && p.y===y && p.color===turn) || null; }

    function onDown(clientX, clientY){
      const {x,y} = squareFromClient(clientX, clientY);
      const p = pickAt(x,y);
      if(p){ selected = p.id; legalMoves = genMoves(p); }
      else if(selected){ const ps = pieces.find(pp=>pp.id===selected); const mv = legalMoves.find(m=>m.x===x && m.y===y); if(mv) movePiece(ps, mv); else { selected=null; legalMoves=[]; } }
      draw();
    }

    canvas.addEventListener('mousedown', e=> onDown(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; onDown(t.clientX, t.clientY); e.preventDefault(); });

    document.getElementById('newGame').addEventListener('click', ()=>{ setupPieces(); draw(); });
    document.getElementById('toggleHints').addEventListener('click', (e)=>{ showHints = !showHints; e.currentTarget.textContent = `Hints: ${showHints? 'On':'Off'}`; draw(); });
    document.getElementById('flip').addEventListener('click', ()=>{ boardFlipped = !boardFlipped; draw(); });

    // Init
    setupPieces();
    draw();
  </script>
</body>
</html>
