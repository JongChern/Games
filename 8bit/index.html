<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lo-fi Drum Sequencer</title>
  <style>
    body {
      font-family: monospace;
      background-color: #111;
      color: #f5f5dc;
      text-align: center;
      padding: 20px;
    }
    .active-queue {
  background-color: #0ff !important;
  color: #000 !important;
  border-color: #0ff !important;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}

    button, input, select {
      margin: 5px;
      font-size: 16px;
      padding: 5px;
    }
    .track-row {
      margin-bottom: 20px;
    }
    .step-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
      gap: 5px;
      justify-content: center;
    }
    .step {
      width: 30px;
      height: 30px;
      background-color: #333;
      border: 2px solid #555;
      cursor: pointer;
    }
    .active {
      background-color: #0f0;
    }
    #sequenceQueue {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      border: 1px solid #0f0;
      padding: 10px;
      min-height: 40px;
    }
    .variation-btn {
      margin: 4px;
      padding: 4px 10px;
      border: 1px solid #0f0;
      background: #222;
      color: #0f0;
      cursor: grab;
    }
    #outputJS {
      white-space: pre-wrap;
      text-align: left;
      margin-top: 10px;
      background: #222;
      color: #0f0;
      padding: 10px;
      border: 1px solid #0f0;
      max-width: 90%;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>
<body>
  <h1>Lo-fi Drum Machine (No Samples)</h1>
  <label for="variationSelect">Variation:</label>
  <select id="variationSelect" onchange="changeVariation(this.value)"></select>
  <button onclick="addVariation()">+ Add Variation</button>
  <button onclick="startVariationPlayback()">Play Variation</button>
  <button onclick="stopVariationPlayback()">Stop Variation</button>
  <button onclick="resetMemory()">Reset Memory</button>
  <br>
  <label for="tempoControl">Tempo (BPM):</label>
  <input type="range" id="tempoControl" min="60" max="180" value="90" oninput="updateTempo(this.value)">
  <span id="tempoDisplay">90</span>

  <h3>Drag Variations Below to Create Playback Sequence</h3>
  <div id="variationList"></div>
  <h4>Playback Queue (drag to reorder or remove)</h4>
  <div id="sequenceQueue" ondragover="event.preventDefault()"></div>
  <button onclick="startSequencePlayback()">Play Sequence</button>
  <button onclick="stopSequencePlayback()">Stop Sequence</button>
  <button onclick="clearQueue()">Clear Queue</button>
  <button onclick="generateSequenceJS()">Generate JS</button>
  <button onclick="generatePlaybackJS()">Generate Playback JS</button>

  <div class="track-row">
    <div>Kick</div>
    <div class="step-grid" id="kickGrid"></div>
  </div>
  <div class="track-row">
    <div>Snare</div>
    <div class="step-grid" id="snareGrid"></div>
  </div>
  <div class="track-row">
    <div>Hat</div>
    <div class="step-grid" id="hatGrid"></div>
  </div>

  <pre id="outputJS"></pre>
<label for="waveformToggle">Waveform:</label>
<select id="waveformToggle">
  <option value="square">Square (classic)</option>
  <option value="triangle" selected>Triangle (whimsical)</option>
</select>
<textarea id="chiptuneInput" rows="4" cols="60">C5:2 E5:2 G5:2 R:2 G5:2 A5:4
F5:2 D5:2 C5:4 R:2 C5:2 G5:4
E5:2 R:2 E5:2 G5:2 A5:4 R:4
C6:2 B5:2 A5:2 G5:2 R:4</textarea><br>
<button onclick="playChiptune()">Play Chiptune</button>
<label><input type="checkbox" id="loopChiptune"> Loop</label>
  <script>
let beatTime = 0;
    const codeString = '';
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stepsPerBar = 16;
    let variations = JSON.parse(localStorage.getItem('variations')) || [];
    let sequence = JSON.parse(localStorage.getItem('sequence')) || [];
    let tempo = parseInt(localStorage.getItem('tempo')) || 90;
    let currentVariation = 0;
    let interval;
    let isPlaying = false;
    let sequenceIndex = 0;
    let step = 0;

    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      const data = e.dataTransfer.getData("text/plain");
      if (data.startsWith("queue:") && !e.target.closest('#sequenceQueue')) {
        const removeIndex = parseInt(data.split(":")[1]);
        sequence.splice(removeIndex, 1);
        localStorage.setItem("sequence", JSON.stringify(sequence));
        updateQueueDisplay();
      }
    });
document.getElementById("sequenceQueue").addEventListener("drop", e => {
  const data = e.dataTransfer.getData("text/plain");
  if (String(data).startsWith("variation:")) {
    const index = parseInt(data.split(":")[1]);
    sequence.push(index); // Always add to end if dropped on container
    localStorage.setItem("sequence", JSON.stringify(sequence));
    updateQueueDisplay();
  }
});
    function addVariation() {
      variations.push({
        kick: Array(stepsPerBar).fill(false),
        snare: Array(stepsPerBar).fill(false),
        hat: Array(stepsPerBar).fill(false)
      });
      currentVariation = variations.length - 1;
      localStorage.setItem('variations', JSON.stringify(variations));
      renderVariationOptions();
      renderAllGrids();
    }

    function changeVariation(index) {
      currentVariation = parseInt(index);
      renderAllGrids();
    }

    function renderAllGrids() {
      renderGrid("kickGrid", "kick");
      renderGrid("snareGrid", "snare");
      renderGrid("hatGrid", "hat");
    }

    function renderGrid(containerId, instrument) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      variations[currentVariation][instrument].forEach((val, i) => {
        const cell = document.createElement('div');
        cell.className = 'step' + (val ? ' active' : '');
        cell.onclick = () => {
          variations[currentVariation][instrument][i] = !val;
          localStorage.setItem('variations', JSON.stringify(variations));
          renderGrid(containerId, instrument);
        };
        container.appendChild(cell);
      });
    }

    function renderVariationOptions() {
      const select = document.getElementById("variationSelect");
      const list = document.getElementById("variationList");
      select.innerHTML = '';
      list.innerHTML = '';
      variations.forEach((_, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = `Variation ${i + 1}`;
        select.appendChild(opt);

        const btn = document.createElement("div");
        btn.className = 'variation-btn';
        btn.textContent = `Variation ${i + 1}`;
        btn.draggable = true;
        btn.dataset.index = i;
        btn.ondragstart = e => e.dataTransfer.setData("text/plain", `variation:${i}`);
        list.appendChild(btn);
      });
    }

    function updateQueueDisplay() {
      const queue = document.getElementById("sequenceQueue");
      queue.innerHTML = '';
      sequence.forEach((i, idx) => {
        const item = document.createElement("div");
        item.className = 'variation-btn' + (idx === sequenceIndex && isPlaying ? ' active-queue' : '');
        item.textContent = `Var ${i + 1}`;
        item.dataset.index = idx;
        item.draggable = true;
        item.ondragstart = e => e.dataTransfer.setData("text/plain", `queue:${idx}`);
        item.ondrop = e => {
          e.preventDefault();
          e.stopPropagation();
          const data = e.dataTransfer.getData("text/plain");
          if (data.startsWith("variation:")) {
            const insertAt = parseInt(e.target.dataset.index);
            const index = parseInt(data.split(":")[1]);
            sequence.splice(insertAt, 0, index);
            localStorage.setItem("sequence", JSON.stringify(sequence));
            updateQueueDisplay();
            return;
          }
          const fromIndex = parseInt(data.split(":")[1]);
          const toIndex = parseInt(e.target.dataset.index);
          if (fromIndex === toIndex) return;
          const moved = sequence.splice(fromIndex, 1)[0];
          const correctedIndex = fromIndex < toIndex ? toIndex + 1 : toIndex;
          sequence.splice(correctedIndex, 0, moved);
          localStorage.setItem("sequence", JSON.stringify(sequence));
          updateQueueDisplay();
        };
        item.ondragover = e => e.preventDefault();
        queue.appendChild(item);
      });
    }

    function clearQueue() {
      sequence = [];
      localStorage.setItem("sequence", JSON.stringify(sequence));
      updateQueueDisplay();
    }

    function resetMemory() {
      localStorage.clear();
      location.reload();
    }

    function updateTempo(val) {
      tempo = parseInt(val);
      localStorage.setItem("tempo", tempo);
      document.getElementById("tempoDisplay").textContent = val;
    }

function startVariationPlayback() {
  if (!variations[currentVariation]) return;
  stopVariationPlayback();
  isPlaying = true;
  step = 0;

  const scheduleAheadTime = 0.1;
  let nextNoteTime = audioCtx.currentTime;

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
      playStepAt(variations[currentVariation], nextNoteTime);
      nextNoteTime += (60 / tempo) / 2;
      step = (step + 1) % stepsPerBar;
    }
    if (isPlaying) requestAnimationFrame(scheduler);
  }

  scheduler();
}

    function stopVariationPlayback() {
      clearInterval(interval);
      isPlaying = false;
    }

    function playStepAt(pattern, time) {
  if (pattern.kick[step]) playKick(time);
  if (pattern.snare[step]) playSnare(time);
  if (pattern.hat[step]) playHat(time);
}

function startSequencePlayback() {
  if (!sequence.length) return;
  stopVariationPlayback();
  step = 0;
  sequenceIndex = 0;
  isPlaying = true;

  currentVariation = sequence[sequenceIndex];
  renderAllGrids();
  updateQueueDisplay();

  const scheduleAheadTime = 0.1;
  nextNoteTime = audioCtx.currentTime;

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
      const pattern = variations[sequence[sequenceIndex]];
      playStepAt(pattern, nextNoteTime);

      step++;
      if (step >= stepsPerBar) {
        step = 0;
        sequenceIndex = (sequenceIndex + 1) % sequence.length;
        currentVariation = sequence[sequenceIndex];
        renderAllGrids();
        updateQueueDisplay();
      }

      nextNoteTime += (60 / tempo) / 2;
    }
    if (isPlaying) requestAnimationFrame(scheduler);
  }

  scheduler();
}


    function stopSequencePlayback() {
  isPlaying = false;
}

    function playStep(pattern) {
  const time = audioCtx.currentTime;
  if (pattern.kick[step]) playKick(time);
  if (pattern.snare[step]) playSnare(time);
  if (pattern.hat[step]) playHat(time);
}

    function playKick(time = audioCtx.currentTime) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(100, time);
  osc.frequency.exponentialRampToValueAtTime(30, time + 0.25);
  gain.gain.setValueAtTime(1, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + 0.25);
    }

    function playSnare(time = audioCtx.currentTime) {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(1000, time);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start(time);
    }

    function playHat(time = audioCtx.currentTime) {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(8000, time);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.3, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start(time);
    }

function generatePlaybackJS(){
   document.getElementById('outputJS').textContent = codeString;
}
    
    function generateSequenceJS() {
      if (!sequence.length) {
        document.getElementById('outputJS').textContent = '// Queue is empty.';
        return;
      }
      let jsOutput = '// Generated playback sequence\n\n';
      jsOutput += 'const sequence = [\n';
      sequence.forEach(index => {
        const v = variations[index];
        jsOutput += `  {\n    kick: ${JSON.stringify(v.kick)},\n    snare: ${JSON.stringify(v.snare)},\n    hat: ${JSON.stringify(v.hat)}\n  },\n`;
      });
      jsOutput += '];\n\n';
      jsOutput += `const tempo = ${tempo};\n`;
      document.getElementById('outputJS').textContent = jsOutput;
      console.log("\n===== GENERATED JS SEQUENCE =====\n" + jsOutput);
    }

    // Initialize
    if (variations.length === 0) addVariation();
    else {
      renderVariationOptions();
      renderAllGrids();
      updateQueueDisplay();
      document.getElementById('tempoControl').value = tempo;
      document.getElementById('tempoDisplay').textContent = tempo;
    }

let chiptuneNotes = [];
let originalChiptuneNotes = [];
let chiptuneIndex = 0;
let isChiptunePlaying = false;
let chiptuneScheduler;
let nextChiptuneTime = 0;

function parseChiptuneInput(input) {
  return input.trim().split(/\s+/).map(token => {
    if (token.startsWith("R:")) {
      return { type: 'rest', duration: parseInt(token.split(":")[1]) };
    } else {
      const [note, dur] = token.split(":");
      return { type: 'note', note, duration: parseInt(dur) };
    }
  });
}

function freqFromNote(note) {
  const noteFreqs = { C: 0, 'C#': 1, D: 2, 'D#': 3, E: 4, F: 5, 'F#': 6, G: 7, 'G#': 8, A: 9, 'A#': 10, B: 11 };
  const match = note.match(/^([A-G]#?)(\d)$/);
  if (!match) return 0;
  const [, n, oct] = match;
  const midi = (parseInt(oct) + 1) * 12 + noteFreqs[n];
  return 440 * Math.pow(2, (midi - 69) / 12);
}

function playNote(noteObj, time) {
  if (noteObj.type === 'rest') return;
  const freq = freqFromNote(noteObj.note);
  if (!isFinite(freq) || freq <= 0) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  // Use triangle wave for whimsical tone
  osc.type = document.getElementById('waveformToggle')?.value || 'triangle';
  osc.frequency.setValueAtTime(freq, time);

  gain.gain.setValueAtTime(0.25, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + 0.3);
}

function playChiptune() {
  const raw = document.getElementById('chiptuneInput').value;
  originalChiptuneNotes = parseChiptuneInput(raw);
  chiptuneNotes = originalChiptuneNotes.slice();
  chiptuneIndex = 0;
  isChiptunePlaying = true;
  nextChiptuneTime = audioCtx.currentTime;
  beatTime = 60 / tempo;

  function schedule() {
    while (chiptuneIndex < chiptuneNotes.length && nextChiptuneTime < audioCtx.currentTime + 0.1) {
      const note = chiptuneNotes[chiptuneIndex];
      playNote(note, nextChiptuneTime);
      nextChiptuneTime += beatTime * (note.duration / 4);
      chiptuneIndex++;
    }
    if (isChiptunePlaying) {
      if (chiptuneIndex < chiptuneNotes.length) {
        chiptuneScheduler = requestAnimationFrame(schedule);
      } else if (document.getElementById('loopChiptune')?.checked) {
        chiptuneNotes = chiptuneNotes.concat(originalChiptuneNotes);
        chiptuneScheduler = requestAnimationFrame(schedule);

      }
    }
  }
  schedule();
}

function stopChiptune() {
  isChiptunePlaying = false;
  cancelAnimationFrame(chiptuneScheduler);
} 

function queueChiptune(melodyString, bpm = tempo, loop = true) {
  stopChiptune();
  originalChiptuneNotes = parseChiptuneInput(melodyString);
  chiptuneNotes = originalChiptuneNotes.slice();
  chiptuneIndex = 0;
  isChiptunePlaying = true;
  nextChiptuneTime = audioCtx.currentTime;
  beatTime = 60 / bpm;

  function schedule() {
    while (chiptuneIndex < chiptuneNotes.length && nextChiptuneTime < audioCtx.currentTime + 0.1) {
      const note = chiptuneNotes[chiptuneIndex];
      playNote(note, nextChiptuneTime);
      nextChiptuneTime += beatTime * (note.duration / 4);
      chiptuneIndex++;
    }
    if (isChiptunePlaying) {
      if (chiptuneIndex < chiptuneNotes.length) {
        chiptuneScheduler = requestAnimationFrame(schedule);
      } else if (loop) {
        chiptuneNotes = chiptuneNotes.concat(originalChiptuneNotes);
        chiptuneScheduler = requestAnimationFrame(schedule);
      }
    }
  }

  schedule();
}

    
  </script>
</body>
</html>
