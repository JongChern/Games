<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lo-fi Drum Sequencer</title>
  <style>
    body {
      font-family: monospace;
      background-color: #111;
      color: #f5f5dc;
      text-align: center;
      padding: 20px;
    }
    button, input, select {
      margin: 5px;
      font-size: 16px;
      padding: 5px;
    }
    .track-row {
      margin-bottom: 20px;
    }
    .step-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
      gap: 5px;
      justify-content: center;
    }
    .step {
      width: 30px;
      height: 30px;
      background-color: #333;
      border: 2px solid #555;
      cursor: pointer;
    }
    .active {
      background-color: #0f0;
    }
    #sequenceQueue {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      border: 1px solid #0f0;
      padding: 10px;
      min-height: 40px;
    }
    .variation-btn {
      margin: 4px;
      padding: 4px 10px;
      border: 1px solid #0f0;
      background: #222;
      color: #0f0;
      cursor: grab;
    }
    #outputJS {
      white-space: pre-wrap;
      text-align: left;
      margin-top: 10px;
      background: #222;
      color: #0f0;
      padding: 10px;
      border: 1px solid #0f0;
      max-width: 90%;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>
<body>
  <h1>Lo-fi Drum Machine (No Samples)</h1>
  <label for="variationSelect">Variation:</label>
  <select id="variationSelect" onchange="changeVariation(this.value)"></select>
  <button onclick="addVariation()">+ Add Variation</button>
  <button onclick="startVariationPlayback()">Play Variation</button>
  <button onclick="stopVariationPlayback()">Stop Variation</button>
  <button onclick="resetMemory()">Reset Memory</button>
  <br>
  <label for="tempoControl">Tempo (BPM):</label>
  <input type="range" id="tempoControl" min="60" max="180" value="90" oninput="updateTempo(this.value)">
  <span id="tempoDisplay">90</span>

  <h3>Drag Variations Below to Create Playback Sequence</h3>
  <div id="variationList"></div>
  <h4>Playback Queue (drag to reorder or remove)</h4>
  <div id="sequenceQueue" ondragover="event.preventDefault()"></div>
  <button onclick="startSequencePlayback()">Play Sequence</button>
  <button onclick="stopSequencePlayback()">Stop Sequence</button>
  <button onclick="clearQueue()">Clear Queue</button>
  <button onclick="generateSequenceJS()">Generate JS</button>
  <button onclick="generatePlaybackJS()">Generate Playback JS</button>

  <div class="track-row">
    <div>Kick</div>
    <div class="step-grid" id="kickGrid"></div>
  </div>
  <div class="track-row">
    <div>Snare</div>
    <div class="step-grid" id="snareGrid"></div>
  </div>
  <div class="track-row">
    <div>Hat</div>
    <div class="step-grid" id="hatGrid"></div>
  </div>

  <pre id="outputJS"></pre>

  <script>

    const codeString = `
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let step = 0;
let sequenceIndex = 0;

function playKick() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(150, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
  gain.gain.setValueAtTime(1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

function playSnare() {
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
  src.connect(filter).connect(gain).connect(audioCtx.destination);
  src.start();
}

function playHat() {
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.setValueAtTime(8000, audioCtx.currentTime);
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
  src.connect(filter).connect(gain).connect(audioCtx.destination);
  src.start();
}

function playStep(pattern) {
  if (pattern.kick[step]) playKick();
  if (pattern.snare[step]) playSnare();
  if (pattern.hat[step]) playHat();
}

setInterval(() => {
  playStep(sequence[sequenceIndex]);
  step++;
  if (step >= 16) {
    step = 0;
    sequenceIndex = (sequenceIndex + 1) % sequence.length;
  }
}, (60000 / tempo) / 2);

`;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stepsPerBar = 16;
    let variations = JSON.parse(localStorage.getItem('variations')) || [];
    let sequence = JSON.parse(localStorage.getItem('sequence')) || [];
    let tempo = parseInt(localStorage.getItem('tempo')) || 90;
    let currentVariation = 0;
    let interval;
    let isPlaying = false;
    let sequenceIndex = 0;
    let step = 0;

    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      const data = e.dataTransfer.getData("text/plain");
      if (data.startsWith("queue:") && !e.target.closest('#sequenceQueue')) {
        const removeIndex = parseInt(data.split(":")[1]);
        sequence.splice(removeIndex, 1);
        localStorage.setItem("sequence", JSON.stringify(sequence));
        updateQueueDisplay();
      }
    });
document.getElementById("sequenceQueue").addEventListener("drop", e => {
  const data = e.dataTransfer.getData("text/plain");
  if (String(data).startsWith("variation:")) {
    const index = parseInt(data.split(":")[1]);
    sequence.push(index); // Always add to end if dropped on container
    localStorage.setItem("sequence", JSON.stringify(sequence));
    updateQueueDisplay();
  }
});
    function addVariation() {
      variations.push({
        kick: Array(stepsPerBar).fill(false),
        snare: Array(stepsPerBar).fill(false),
        hat: Array(stepsPerBar).fill(false)
      });
      currentVariation = variations.length - 1;
      localStorage.setItem('variations', JSON.stringify(variations));
      renderVariationOptions();
      renderAllGrids();
    }

    function changeVariation(index) {
      currentVariation = parseInt(index);
      renderAllGrids();
    }

    function renderAllGrids() {
      renderGrid("kickGrid", "kick");
      renderGrid("snareGrid", "snare");
      renderGrid("hatGrid", "hat");
    }

    function renderGrid(containerId, instrument) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      variations[currentVariation][instrument].forEach((val, i) => {
        const cell = document.createElement('div');
        cell.className = 'step' + (val ? ' active' : '');
        cell.onclick = () => {
          variations[currentVariation][instrument][i] = !val;
          localStorage.setItem('variations', JSON.stringify(variations));
          renderGrid(containerId, instrument);
        };
        container.appendChild(cell);
      });
    }

    function renderVariationOptions() {
      const select = document.getElementById("variationSelect");
      const list = document.getElementById("variationList");
      select.innerHTML = '';
      list.innerHTML = '';
      variations.forEach((_, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = `Variation ${i + 1}`;
        select.appendChild(opt);

        const btn = document.createElement("div");
        btn.className = 'variation-btn';
        btn.textContent = `Variation ${i + 1}`;
        btn.draggable = true;
        btn.dataset.index = i;
        btn.ondragstart = e => e.dataTransfer.setData("text/plain", `variation:${i}`);
        list.appendChild(btn);
      });
    }

    function updateQueueDisplay() {
      const queue = document.getElementById("sequenceQueue");
      queue.innerHTML = '';
      sequence.forEach((i, idx) => {
        const item = document.createElement("div");
        item.className = 'variation-btn';
        item.textContent = `Var ${i + 1}`;
        item.dataset.index = idx;
        item.draggable = true;
        item.ondragstart = e => e.dataTransfer.setData("text/plain", `queue:${idx}`);
        item.ondrop = e => {
          e.preventDefault();
          e.stopPropagation();
          const data = e.dataTransfer.getData("text/plain");
          if (data.startsWith("variation:")) {
            const insertAt = parseInt(e.target.dataset.index);
            const index = parseInt(data.split(":")[1]);
            sequence.splice(insertAt, 0, index);
            localStorage.setItem("sequence", JSON.stringify(sequence));
            updateQueueDisplay();
            return;
          }
          const fromIndex = parseInt(data.split(":")[1]);
          const toIndex = parseInt(e.target.dataset.index);
          if (fromIndex === toIndex) return;
          const moved = sequence.splice(fromIndex, 1)[0];
          const correctedIndex = fromIndex < toIndex ? toIndex + 1 : toIndex;
          sequence.splice(correctedIndex, 0, moved);
          localStorage.setItem("sequence", JSON.stringify(sequence));
          updateQueueDisplay();
        };
        item.ondragover = e => e.preventDefault();
        queue.appendChild(item);
      });
    }

    function clearQueue() {
      sequence = [];
      localStorage.setItem("sequence", JSON.stringify(sequence));
      updateQueueDisplay();
    }

    function resetMemory() {
      localStorage.clear();
      location.reload();
    }

    function updateTempo(val) {
      tempo = parseInt(val);
      localStorage.setItem("tempo", tempo);
      document.getElementById("tempoDisplay").textContent = val;
    }

    function startVariationPlayback() {
      if (!variations[currentVariation]) return;
      stopVariationPlayback();
      isPlaying = true;
      step = 0;
      interval = setInterval(() => {
        playStep(variations[currentVariation]);
        step = (step + 1) % stepsPerBar;
      }, (60000 / tempo) / 2);
    }

    function stopVariationPlayback() {
      clearInterval(interval);
      isPlaying = false;
    }

    function startSequencePlayback() {
      if (!sequence.length) return;
      stopVariationPlayback();
      step = 0;
      sequenceIndex = 0;
      isPlaying = true;
      interval = setInterval(() => {
        playStep(variations[sequence[sequenceIndex]]);
        step++;
        if (step >= stepsPerBar) {
  step = 0;
  sequenceIndex = (sequenceIndex + 1) % sequence.length;
  currentVariation = sequence[sequenceIndex];
  renderAllGrids(); // 🔁 visually update to match current variation
}
      }, (60000 / tempo) / 2);
    }

    function stopSequencePlayback() {
      clearInterval(interval);
      isPlaying = false;
    }

    function playStep(pattern) {
      if (pattern.kick[step]) playKick();
      if (pattern.snare[step]) playSnare();
      if (pattern.hat[step]) playHat();
    }

    function playKick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function playSnare() {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start();
    }

    function playHat() {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(8000, audioCtx.currentTime);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start();
    }

function generatePlaybackJS(){
   document.getElementById('outputJS').textContent = codeString;
}
    
    function generateSequenceJS() {
      if (!sequence.length) {
        document.getElementById('outputJS').textContent = '// Queue is empty.';
        return;
      }
      let jsOutput = '// Generated playback sequence\n\n';
      jsOutput += 'const sequence = [\n';
      sequence.forEach(index => {
        const v = variations[index];
        jsOutput += `  {\n    kick: ${JSON.stringify(v.kick)},\n    snare: ${JSON.stringify(v.snare)},\n    hat: ${JSON.stringify(v.hat)}\n  },\n`;
      });
      jsOutput += '];\n\n';
      jsOutput += `const tempo = ${tempo};\n`;
      document.getElementById('outputJS').textContent = jsOutput;
      console.log("\n===== GENERATED JS SEQUENCE =====\n" + jsOutput);
    }

    // Initialize
    if (variations.length === 0) addVariation();
    else {
      renderVariationOptions();
      renderAllGrids();
      updateQueueDisplay();
      document.getElementById('tempoControl').value = tempo;
      document.getElementById('tempoDisplay').textContent = tempo;
    }
  </script>
</body>
</html>
