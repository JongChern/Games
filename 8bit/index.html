<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lo-fi Drum Sequencer</title>
  <style>
    body {
      font-family: monospace;
      background-color: #111;
      color: #f5f5dc;
      text-align: center;
      padding: 20px;
    }
    .active-queue {
  background-color: #0ff !important;
  color: #000 !important;
  border-color: #0ff !important;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}

    button, input, select {
      margin: 5px;
      font-size: 16px;
      padding: 5px;
    }
    .track-row {
      margin-bottom: 20px;
    }
    .step-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
      gap: 5px;
      justify-content: center;
    }
    .step {
      width: 30px;
      height: 30px;
      background-color: #333;
      border: 2px solid #555;
      cursor: pointer;
    }
    .active {
      background-color: #0f0;
    }
    #sequenceQueue {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      border: 1px solid #0f0;
      padding: 10px;
      min-height: 40px;
    }
    .variation-btn {
      margin: 4px;
      padding: 4px 10px;
      border: 1px solid #0f0;
      background: #222;
      color: #0f0;
      cursor: grab;
    }
    #outputJS {
      white-space: pre-wrap;
      text-align: left;
      margin-top: 10px;
      background: #222;
      color: #0f0;
      padding: 10px;
      border: 1px solid #0f0;
      max-width: 90%;
      margin-left: auto;
      margin-right: auto;
    }
	#chiptuneSequenceQueue {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 10px;
  border: 1px solid #0f0;
  padding: 10px;
  min-height: 40px;
}
#masterPercQueue, #masterChipQueue {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin: 10px 0;
  padding: 10px;
  min-height: 50px;
  border: 2px dashed #0f0;
  background-color: #222;
}
  </style>
</head>
<div>
	<button onclick="showTab('master')">Master</button>
  <button onclick="showTab('percussion')">Percussion</button>
  <button onclick="showTab('chiptune')">Chiptune</button>
</div>
<div id="masterTab" style="display:none;">
  <h1>Master Sequencer</h1>

  <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
    <div>
      <h3>Percussion Variations</h3>
      <div id="masterPercussionList"></div>
    </div>
    <div>
      <h3>Chiptune Variations</h3>
      <div id="masterChiptuneList"></div>
    </div>
  </div>

  <h4>Percussion Sequence Queue</h4>
  <div id="masterPercQueue" ondragover="event.preventDefault()"></div>

  <h4>Chiptune Sequence Queue</h4>
  <div id="masterChipQueue" ondragover="event.preventDefault()"></div>

  <button onclick="startMasterSequence()">Play Master Sequence</button>
  <button onclick="stopMasterSequence()">Stop Master Sequence</button>
  <button onclick="clearMasterQueues()">Clear Master Queue</button>
</div>


<div id="percussionTab"><h1>Lo-fi Drum Machine (No Samples)</h1>
  <label for="variationSelect">Variation:</label>
  <select id="variationSelect" onchange="changeVariation(this.value)"></select>
  <button onclick="addVariation()">+ Add Variation</button>
  <button onclick="startVariationPlayback()">Play Variation</button>
  <button onclick="stopVariationPlayback()">Stop Variation</button>
  <button onclick="resetMemory()">Reset Memory</button>
  <br>
  <label for="tempoControl">Tempo (BPM):</label>
  <input type="range" id="tempoControl" min="60" max="180" value="90" oninput="updateTempo(this.value)">
  <span id="tempoDisplay">90</span>

  <h3>Drag Variations Below to Create Playback Sequence</h3>
  <div id="variationList"></div>
  <h4>Playback Queue (drag to reorder or remove)</h4>
  <div id="sequenceQueue" ondragover="event.preventDefault()"></div>
  <button onclick="startSequencePlayback()">Play Sequence</button>
  <button onclick="stopSequencePlayback()">Stop Sequence</button>
  <button onclick="clearQueue()">Clear Queue</button>
  <button onclick="generateSequenceJS()">Generate JS</button>
  <button onclick="generatePlaybackJS()">Generate Playback JS</button>

  <div class="track-row">
    <div>Kick</div>
    <div class="step-grid" id="kickGrid"></div>
  </div>
  <div class="track-row">
    <div>Snare</div>
    <div class="step-grid" id="snareGrid"></div>
  </div>
  <div class="track-row">
    <div>Hat</div>
    <div class="step-grid" id="hatGrid"></div>
  </div>

  </div>
<div id="chiptuneTab" style="display:none;">
  <h1>Chiptune Sequencer</h1>
  <label for="chiptuneVariationSelect">Variation:</label>
  <select id="chiptuneVariationSelect" onchange="changeChiptuneVariation(this.value)"></select>
  <button onclick="addChiptuneVariation()">+ Add Variation</button>
  <button onclick="playChiptuneVariation()">Play Variation</button>
  <button onclick="stopChiptune()">Stop Variation</button>

  <h3>Drag Variations Below to Create Chiptune Playback Sequence</h3>
  <div id="chiptuneVariationList"></div>

  <h4>Chiptune Playback Queue (drag to reorder or remove)</h4>
  <div id="chiptuneSequenceQueue" ondragover="event.preventDefault()"></div>
  <button onclick="startChiptuneSequence()">Play Chiptune Sequence</button>
  <button onclick="stopChiptune()">Stop Sequence</button>
  <button onclick="clearChiptuneQueue()">Clear Queue</button>

  <label for="waveformToggle">Waveform:</label>
  <select id="waveformToggle">
    <option value="square">Square (classic)</option>
    <option value="triangle" selected>Triangle (whimsical)</option>
  </select>

  <textarea id="chiptuneInput" rows="4" cols="60">C5:2 E5:2 G5:2 R:2 G5:2 A5:4
F5:2 D5:2 C5:4 R:2 C5:2 G5:4
E5:2 R:2 E5:2 G5:2 A5:4 R:4
C6:2 B5:2 A5:2 G5:2 R:4</textarea><br>

  <button onclick="playChiptune()">Play Chiptune</button>
  <label><input type="checkbox" id="loopChiptune"> Loop</label>
</div>

  <script>
let beatTime = 0;
    const codeString = '';
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stepsPerBar = 16;
    let variations = JSON.parse(localStorage.getItem('variations')) || [];
    let sequence = JSON.parse(localStorage.getItem('sequence')) || [];
    let tempo = parseInt(localStorage.getItem('tempo')) || 90;
    let currentVariation = 0;
    let interval;
    let isPlaying = false;
    let sequenceIndex = 0;
    let step = 0;
let masterPercQueue = JSON.parse(localStorage.getItem('masterPercQueue')) || [];
let masterChipQueue = JSON.parse(localStorage.getItem('masterChipQueue')) || [];

    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => {
      const data = e.dataTransfer.getData("text/plain");
      if (data.startsWith("queue:") && !e.target.closest('#sequenceQueue')) {
        const removeIndex = parseInt(data.split(":")[1]);
        sequence.splice(removeIndex, 1);
        localStorage.setItem("sequence", JSON.stringify(sequence));
        updateQueueDisplay();
      }
    });
document.getElementById("sequenceQueue").addEventListener("drop", e => {
  const data = e.dataTransfer.getData("text/plain");
  if (String(data).startsWith("variation:")) {
    const index = parseInt(data.split(":")[1]);
    sequence.push(index); // Always add to end if dropped on container
    localStorage.setItem("sequence", JSON.stringify(sequence));
    updateQueueDisplay();
  }
});
    function addVariation() {
      variations.push({
        kick: Array(stepsPerBar).fill(false),
        snare: Array(stepsPerBar).fill(false),
        hat: Array(stepsPerBar).fill(false)
      });
      currentVariation = variations.length - 1;
      localStorage.setItem('variations', JSON.stringify(variations));
      renderVariationOptions();
      renderAllGrids();
	  renderMasterLists(); // Ensure Master tab picks up new variations

    }

    function changeVariation(index) {
      currentVariation = parseInt(index);
      renderAllGrids();
    }

    function renderAllGrids() {
      renderGrid("kickGrid", "kick");
      renderGrid("snareGrid", "snare");
      renderGrid("hatGrid", "hat");
    }

    function renderGrid(containerId, instrument) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      variations[currentVariation][instrument].forEach((val, i) => {
        const cell = document.createElement('div');
        cell.className = 'step' + (val ? ' active' : '');
        cell.onclick = () => {
          variations[currentVariation][instrument][i] = !val;
          localStorage.setItem('variations', JSON.stringify(variations));
          renderGrid(containerId, instrument);
        };
        container.appendChild(cell);
      });
    }

    function renderVariationOptions() {
      const select = document.getElementById("variationSelect");
      const list = document.getElementById("variationList");
      select.innerHTML = '';
      list.innerHTML = '';
      variations.forEach((_, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = `Variation ${i + 1}`;
        select.appendChild(opt);

        const btn = document.createElement("div");
        btn.className = 'variation-btn';
        btn.textContent = `Variation ${i + 1}`;
        btn.draggable = true;
        btn.dataset.index = i;
        btn.ondragstart = e => e.dataTransfer.setData("text/plain", `variation:${i}`);
        list.appendChild(btn);
      });
    }

    function updateQueueDisplay() {
      const queue = document.getElementById("sequenceQueue");
      queue.innerHTML = '';
      sequence.forEach((i, idx) => {
        const item = document.createElement("div");
        item.className = 'variation-btn' + (idx === sequenceIndex && isPlaying ? ' active-queue' : '');
        item.textContent = `Var ${i + 1}`;
        item.dataset.index = idx;
        item.draggable = true;
        item.ondragstart = e => e.dataTransfer.setData("text/plain", `queue:${idx}`);
        item.ondrop = e => {
          e.preventDefault();
          e.stopPropagation();
          const data = e.dataTransfer.getData("text/plain");
          if (data.startsWith("variation:")) {
            const insertAt = parseInt(e.target.dataset.index);
            const index = parseInt(data.split(":")[1]);
            sequence.splice(insertAt, 0, index);
            localStorage.setItem("sequence", JSON.stringify(sequence));
            updateQueueDisplay();
            return;
          }
          const fromIndex = parseInt(data.split(":")[1]);
          const toIndex = parseInt(e.target.dataset.index);
          if (fromIndex === toIndex) return;
          const moved = sequence.splice(fromIndex, 1)[0];
          const correctedIndex = fromIndex < toIndex ? toIndex + 1 : toIndex;
          sequence.splice(correctedIndex, 0, moved);
          localStorage.setItem("sequence", JSON.stringify(sequence));
          updateQueueDisplay();
        };
        item.ondragover = e => e.preventDefault();
        queue.appendChild(item);
      });
    }

    function clearQueue() {
      sequence = [];
      localStorage.setItem("sequence", JSON.stringify(sequence));
      updateQueueDisplay();
    }

    function resetMemory() {
      localStorage.clear();
      location.reload();
    }

    function updateTempo(val) {
      tempo = parseInt(val);
      localStorage.setItem("tempo", tempo);
      document.getElementById("tempoDisplay").textContent = val;
    }

function startVariationPlayback() {
  if (!variations[currentVariation]) return;
  stopVariationPlayback();
  isPlaying = true;
  step = 0;

  const scheduleAheadTime = 0.1;
  let nextNoteTime = audioCtx.currentTime;

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
      playStepAt(variations[currentVariation], nextNoteTime);
      nextNoteTime += (60 / tempo) / 2;
      step = (step + 1) % stepsPerBar;
    }
    if (isPlaying) requestAnimationFrame(scheduler);
  }

  scheduler();
}

    function stopVariationPlayback() {
      clearInterval(interval);
      isPlaying = false;
    }

function playStepAt(pattern, time, stepIndex = step) {
  if (pattern.kick[stepIndex]) playKick(time);
  if (pattern.snare[stepIndex]) playSnare(time);
  if (pattern.hat[stepIndex]) playHat(time);
}

function startSequencePlayback() {
  if (!sequence.length) return;
  stopVariationPlayback();
  step = 0;
  sequenceIndex = 0;
  isPlaying = true;

  currentVariation = sequence[sequenceIndex];
  renderAllGrids();
  updateQueueDisplay();

  const scheduleAheadTime = 0.1;
  nextNoteTime = audioCtx.currentTime;

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
      const pattern = variations[sequence[sequenceIndex]];
      playStepAt(pattern, nextNoteTime);

      step++;
      if (step >= stepsPerBar) {
        step = 0;
        sequenceIndex = (sequenceIndex + 1) % sequence.length;
        currentVariation = sequence[sequenceIndex];
        renderAllGrids();
        updateQueueDisplay();
      }

      nextNoteTime += (60 / tempo) / 2;
    }
    if (isPlaying) requestAnimationFrame(scheduler);
  }

  scheduler();
}


    function stopSequencePlayback() {
  isPlaying = false;
}

    function playStep(pattern) {
  const time = audioCtx.currentTime;
  if (pattern.kick[step]) playKick(time);
  if (pattern.snare[step]) playSnare(time);
  if (pattern.hat[step]) playHat(time);
}

    function playKick(time = audioCtx.currentTime) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(100, time);
  osc.frequency.exponentialRampToValueAtTime(30, time + 0.25);
  gain.gain.setValueAtTime(1, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + 0.25);
    }

    function playSnare(time = audioCtx.currentTime) {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(1000, time);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start(time);
    }

    function playHat(time = audioCtx.currentTime) {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(8000, time);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.3, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
      src.connect(filter).connect(gain).connect(audioCtx.destination);
      src.start(time);
    }

function generatePlaybackJS(){
   document.getElementById('outputJS').textContent = codeString;
}
    
    function generateSequenceJS() {
      if (!sequence.length) {
        document.getElementById('outputJS').textContent = '// Queue is empty.';
        return;
      }
      let jsOutput = '// Generated playback sequence\n\n';
      jsOutput += 'const sequence = [\n';
      sequence.forEach(index => {
        const v = variations[index];
        jsOutput += `  {\n    kick: ${JSON.stringify(v.kick)},\n    snare: ${JSON.stringify(v.snare)},\n    hat: ${JSON.stringify(v.hat)}\n  },\n`;
      });
      jsOutput += '];\n\n';
      jsOutput += `const tempo = ${tempo};\n`;
      document.getElementById('outputJS').textContent = jsOutput;
      console.log("\n===== GENERATED JS SEQUENCE =====\n" + jsOutput);
    }

    // Initialize
    if (variations.length === 0) addVariation();
    else {
      renderVariationOptions();
      renderAllGrids();
      updateQueueDisplay();
      document.getElementById('tempoControl').value = tempo;
      document.getElementById('tempoDisplay').textContent = tempo;
    }

let chiptuneNotes = [];
let chiptuneVariations = JSON.parse(localStorage.getItem('chiptuneVariations')) || [];
let chiptuneSequence = JSON.parse(localStorage.getItem('chiptuneSequence')) || [];
let currentChiptuneVariation = 0;
let originalChiptuneNotes = [];
let chiptuneIndex = 0;
let isChiptunePlaying = false;
let chiptuneScheduler;
let nextChiptuneTime = 0;

function parseChiptuneInput(input) {
  return input.trim().split(/\s+/).map(token => {
    if (token.startsWith("R:")) {
      return { type: 'rest', duration: parseInt(token.split(":")[1]) };
    } else {
      const [note, dur] = token.split(":");
      return { type: 'note', note, duration: parseInt(dur) };
    }
  });
}

function freqFromNote(note) {
  const noteFreqs = { C: 0, 'C#': 1, D: 2, 'D#': 3, E: 4, F: 5, 'F#': 6, G: 7, 'G#': 8, A: 9, 'A#': 10, B: 11 };
  const match = note.match(/^([A-G]#?)(\d)$/);
  if (!match) return 0;
  const [, n, oct] = match;
  const midi = (parseInt(oct) + 1) * 12 + noteFreqs[n];
  return 440 * Math.pow(2, (midi - 69) / 12);
}

function playNote(noteObj, time) {
  if (noteObj.type === 'rest') return;
  const freq = freqFromNote(noteObj.note);
  if (!isFinite(freq) || freq <= 0) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  // Use triangle wave for whimsical tone
  osc.type = document.getElementById('waveformToggle')?.value || 'triangle';
  osc.frequency.setValueAtTime(freq, time);

  gain.gain.setValueAtTime(0.25, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + 0.3);
}

function playChiptune() {
  const raw = document.getElementById('chiptuneInput').value;
  originalChiptuneNotes = parseChiptuneInput(raw);
  chiptuneNotes = originalChiptuneNotes.slice();
  chiptuneIndex = 0;
  isChiptunePlaying = true;
  nextChiptuneTime = audioCtx.currentTime;
  beatTime = 60 / tempo;

  function schedule() {
    while (chiptuneIndex < chiptuneNotes.length && nextChiptuneTime < audioCtx.currentTime + 0.1) {
      const note = chiptuneNotes[chiptuneIndex];
      playNote(note, nextChiptuneTime);
      nextChiptuneTime += beatTime * (note.duration / 4);
      chiptuneIndex++;
    }
    if (isChiptunePlaying) {
      if (chiptuneIndex < chiptuneNotes.length) {
        chiptuneScheduler = requestAnimationFrame(schedule);
      } else if (document.getElementById('loopChiptune')?.checked) {
        chiptuneNotes = chiptuneNotes.concat(originalChiptuneNotes);
        chiptuneScheduler = requestAnimationFrame(schedule);

      }
    }
  }
  schedule();
}

function stopChiptune() {
  isChiptunePlaying = false;
  cancelAnimationFrame(chiptuneScheduler);
}

function addChiptuneVariation() {
  chiptuneVariations.push(document.getElementById('chiptuneInput').value);
  currentChiptuneVariation = chiptuneVariations.length - 1;
  localStorage.setItem('chiptuneVariations', JSON.stringify(chiptuneVariations));
  renderChiptuneVariationOptions();
  document.getElementById('chiptuneInput').value = chiptuneVariations[currentChiptuneVariation];
  renderMasterLists(); // Ensure Master tab picks up new variations

}

function changeChiptuneVariation(index) {
  currentChiptuneVariation = parseInt(index);
  document.getElementById('chiptuneInput').value = chiptuneVariations[currentChiptuneVariation];
}

function renderChiptuneVariationOptions() {
  const select = document.getElementById("chiptuneVariationSelect");
  const list = document.getElementById("chiptuneVariationList");
  select.innerHTML = '';
  list.innerHTML = '';
  chiptuneVariations.forEach((_, i) => {
    const opt = document.createElement("option");
    opt.value = i;
    opt.text = `Variation ${i + 1}`;
    select.appendChild(opt);

    const btn = document.createElement("div");
    btn.className = 'variation-btn';
    btn.textContent = `Variation ${i + 1}`;
    btn.draggable = true;
    btn.dataset.index = i;
    btn.ondragstart = e => e.dataTransfer.setData("text/plain", `chiptune:${i}`);
    list.appendChild(btn);
  });
}

document.getElementById("chiptuneSequenceQueue").addEventListener("drop", e => {
  const data = e.dataTransfer.getData("text/plain");
  if (String(data).startsWith("chiptune:")) {
    const index = parseInt(data.split(":")[1]); // ✅ CORRECTED
    chiptuneSequence.push(index);
    localStorage.setItem("chiptuneSequence", JSON.stringify(chiptuneSequence));
    updateChiptuneQueueDisplay();
  }
});


function updateChiptuneQueueDisplay() {
  const queue = document.getElementById("chiptuneSequenceQueue");
  queue.innerHTML = '';
  chiptuneSequence.forEach((i, idx) => {
    const item = document.createElement("div");
    item.className = 'variation-btn';
    item.textContent = `Var ${i + 1}`;
    item.dataset.index = idx;
    item.draggable = true;
    item.ondragstart = e => e.dataTransfer.setData("text/plain", `chiptune:${i}`);

    item.ondragover = e => e.preventDefault();
    item.ondrop = e => {
      e.preventDefault();
      e.stopPropagation();
      const dragData = e.dataTransfer.getData("text/plain");
      if (dragData.startsWith("chiptune:")) {
		const insertAt = parseInt(e.target.dataset.index);
		const index = parseInt(dragData.split(":")[1]); // ✅ FIXED
        chiptuneSequence.splice(insertAt, 0, index);
        localStorage.setItem("chiptuneSequence", JSON.stringify(chiptuneSequence));
        updateChiptuneQueueDisplay();
        return;
      }
      const fromIndex = parseInt(dragData.split(":")[1]);
      const toIndex = parseInt(e.target.dataset.index);
      if (fromIndex === toIndex) return;
      const moved = chiptuneSequence.splice(fromIndex, 1)[0];
      const correctedIndex = fromIndex < toIndex ? toIndex + 1 : toIndex;
      chiptuneSequence.splice(correctedIndex, 0, moved);
      localStorage.setItem("chiptuneSequence", JSON.stringify(chiptuneSequence));
      updateChiptuneQueueDisplay();
    };
    queue.appendChild(item);
  });
}

function clearChiptuneQueue() {
  chiptuneSequence = [];
  localStorage.setItem("chiptuneSequence", JSON.stringify(chiptuneSequence));
  updateChiptuneQueueDisplay();
}

function playChiptuneVariation() {
  queueChiptune(chiptuneVariations[currentChiptuneVariation] || '');
}

function startChiptuneSequence() {
  if (!chiptuneSequence.length) return;
  stopChiptune();
  let index = 0;
  function playNext() {
    if (index >= chiptuneSequence.length) return;
    queueChiptune(chiptuneVariations[chiptuneSequence[index]], tempo, false);
    index++;
    const duration = chiptuneNotes.reduce((sum, n) => sum + (n.duration || 1), 0) * (60 / tempo) * 250; // estimated duration
    setTimeout(playNext, duration);
  }
  playNext();
} 

function queueChiptune(melodyString, bpm = tempo, loop = true, startTime = audioCtx.currentTime) {
  stopChiptune();
  originalChiptuneNotes = parseChiptuneInput(melodyString);
  chiptuneNotes = originalChiptuneNotes.slice();
  chiptuneIndex = 0;
  isChiptunePlaying = true;
  nextChiptuneTime = startTime; // ← USE startTime here
  beatTime = 60 / bpm;

  function schedule() {
    while (chiptuneIndex < chiptuneNotes.length && nextChiptuneTime < audioCtx.currentTime + 0.1) {
      const note = chiptuneNotes[chiptuneIndex];
      playNote(note, nextChiptuneTime);
      nextChiptuneTime += beatTime * (note.duration / 4);
      chiptuneIndex++;
    }
    if (isChiptunePlaying) {
      if (chiptuneIndex < chiptuneNotes.length) {
        chiptuneScheduler = requestAnimationFrame(schedule);
      } else if (loop) {
        chiptuneNotes = chiptuneNotes.concat(originalChiptuneNotes);
        chiptuneScheduler = requestAnimationFrame(schedule);
      }
    }
  }

  schedule();
}
document.getElementById("chiptuneInput").addEventListener("input", () => {
  if (chiptuneVariations.length > 0) {
    chiptuneVariations[currentChiptuneVariation] = document.getElementById("chiptuneInput").value;
    localStorage.setItem('chiptuneVariations', JSON.stringify(chiptuneVariations));
  }
});
function showTab(tab) {
  ['percussionTab', 'chiptuneTab', 'masterTab'].forEach(id => {
    document.getElementById(id).style.display = id === tab + 'Tab' ? '' : 'none';
  });
}
// Initialize chiptune variation/queue UI
if (chiptuneVariations.length > 0) {
  renderChiptuneVariationOptions();
  updateChiptuneQueueDisplay();
}
if (chiptuneVariations.length === 0) {
  addChiptuneVariation();
}

function renderMasterLists() {
  const perList = document.getElementById("masterPercussionList");
  const chipList = document.getElementById("masterChiptuneList");
  perList.innerHTML = '';
  chipList.innerHTML = '';

  variations.forEach((_, i) => {
    const btn = document.createElement("div");
    btn.className = 'variation-btn';
    btn.textContent = `Perc ${i + 1}`;
    btn.draggable = true;
    btn.ondragstart = e => e.dataTransfer.setData("text/plain", `masterPerc:${i}`);
    perList.appendChild(btn);
  });

  chiptuneVariations.forEach((_, i) => {
    const btn = document.createElement("div");
    btn.className = 'variation-btn';
    btn.textContent = `Chip ${i + 1}`;
    btn.draggable = true;
    btn.ondragstart = e => e.dataTransfer.setData("text/plain", `masterChip:${i}`);
    chipList.appendChild(btn);
  });
}

["masterPercQueue", "masterChipQueue"].forEach(id => {
  document.getElementById(id).addEventListener("drop", e => {
    const data = e.dataTransfer.getData("text/plain");
    if (data.startsWith("masterPerc:")) {
      masterPercQueue.push(parseInt(data.split(":")[1]));
    } else if (data.startsWith("masterChip:")) {
      masterChipQueue.push(parseInt(data.split(":")[1]));
    }
    updateMasterQueues();
  });
});

function updateMasterQueues() {
  const perc = document.getElementById("masterPercQueue");
  const chip = document.getElementById("masterChipQueue");
  perc.innerHTML = '';
  chip.innerHTML = '';

  masterPercQueue.forEach(i => {
    const div = document.createElement("div");
    div.className = 'variation-btn';
    div.textContent = `Perc ${i + 1}`;
    perc.appendChild(div);
  });

  masterChipQueue.forEach(i => {
    const div = document.createElement("div");
    div.className = 'variation-btn';
    div.textContent = `Chip ${i + 1}`;
    chip.appendChild(div);
  });

  // Save to localStorage
  localStorage.setItem('masterPercQueue', JSON.stringify(masterPercQueue));
  localStorage.setItem('masterChipQueue', JSON.stringify(masterChipQueue));
}
function startMasterSequence() {
  if (!masterPercQueue.length && !masterChipQueue.length) return;
  let pIdx = 0, cIdx = 0, stepInBar = 0;
  let nextNoteTime = audioCtx.currentTime;
  const scheduleAhead = 0.1;
  const beatTime = 60 / tempo / 2;

  isPlaying = true;

  function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAhead) {
      const pVar = variations[masterPercQueue[pIdx % masterPercQueue.length]];
      if (pVar) {
        playStepAt(pVar, nextNoteTime, stepInBar); // ← pass stepInBar explicitly
      }

      if (stepInBar === 0 && masterChipQueue.length > 0) {
        const chipVar = chiptuneVariations[masterChipQueue[cIdx % masterChipQueue.length]];
        if (chipVar) queueChiptune(chipVar, tempo, false, nextNoteTime);
        cIdx++;
      }

      stepInBar++;
      if (stepInBar >= stepsPerBar) {
        stepInBar = 0;
        pIdx++;
      }

      nextNoteTime += beatTime;
    }

    if (isPlaying) requestAnimationFrame(scheduler);
  }

  scheduler();
}



function stopMasterSequence() {
  isPlaying = false;
  stopChiptune();
}

function clearMasterQueues() {
  masterPercQueue = [];
  masterChipQueue = [];
  updateMasterQueues();
}

renderMasterLists();
updateMasterQueues();

  </script>

</html>
